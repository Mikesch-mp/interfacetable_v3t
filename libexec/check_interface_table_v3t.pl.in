#!/usr/bin/perl
# nagios: -epn

# ------------------------------------------------------------------------
# COPYRIGHT:
#
# This software and the additional scripts provided with this software are
# Copyright (c) 2011 Yannick Charton (tontonitch-pro@yahoo.fr)
# (Except where explicitly superseded by other copyright notices)
#
# LICENSE:
#
# This work is made available to you under the terms of version 3 of
# the GNU General Public License. A copy of that license should have
# been provided with this software. 
# If not, see <http://www.gnu.org/licenses/>.
#
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# Nagios and the Nagios logo are registered trademarks of Ethan Galstad.
# ------------------------------------------------------------------------

use strict;
use warnings;

use lib ('@nagios_libexec@');
use lib ('@libdir@');
use Net::SNMP qw(oid_base_match);
use Config::General;
use Data::Dumper;
  $Data::Dumper::Sortkeys = 1;
use Getopt::Long qw(:config no_ignore_case no_ignore_case_always bundling_override);
use utils qw(%ERRORS $TIMEOUT); # gather variables from utils.pm
use GeneralUtils;
use Settings;
use SnmpUtils;

# ========================================================================
# VARIABLES
# ========================================================================

# ------------------------------------------------------------------------
# global variable definitions
# ------------------------------------------------------------------------
use vars qw($PROGNAME $REVISION $CONTACT $TIMEOUT);
$PROGNAME       = $0;
$REVISION       = '0.03';
$CONTACT        = 'tontonitch-pro@yahoo.fr';
#$TIMEOUT       = 120;
#my %ERRORS     = ('OK'=>0,'WARNING'=>1,'CRITICAL'=>2,'UNKNOWN'=>3,'DEPENDENT'=>4);
my %ERRORCODES  = (0=>'OK',1=>'WARNING',2=>'CRITICAL',3=>'UNKNOWN',4=>'DEPENDENT');
my %COLORS      = ('HighLight' => '#81BEF7');
my $UMASK       = "0000";
my $TMPDIR      = File::Spec->tmpdir();         # define cache directory or use /tmp
my $STARTTIME   = time ();                                      # time of program start
my $css_stylesheet	= "icinga.css";
my $feature_interfaceInfoDetail = 0;
# NOT USED - my $refhPath = {};

# ------------------------------------------------------------------------
# OIDs definitions
# ------------------------------------------------------------------------

my $oid_sysDescr        = ".1.3.6.1.2.1.1.1.0";
my $oid_sysName         = ".1.3.6.1.2.1.1.5.0";
my $oid_sysUpTime       = ".1.3.6.1.2.1.1.3.0";

my $oid_ifDescr         = ".1.3.6.1.2.1.2.2.1.2";   # + ".<index>"
my $oid_ifSpeed         = ".1.3.6.1.2.1.2.2.1.5";   # + ".<index>"

my $oid_ifPhysAddress   = ".1.3.6.1.2.1.2.2.1.6";   # + ".<index>"
my $oid_ifAdminStatus   = ".1.3.6.1.2.1.2.2.1.7";   # + ".<index>"
my $oid_ifOperStatus    = ".1.3.6.1.2.1.2.2.1.8";   # + ".<index>"
my $oid_ifLastChange    = ".1.3.6.1.2.1.2.2.1.9";   # + ".<index>"

# RFC1213 - Extracts about in/out stats
# ------------------------------------------------------------------------
# in_octet:     The total number of octets received on the interface, including framing characters.
# in_error:     The number of inbound packets that contained errors preventing them from being deliverable to a
#               higher-layer protocol.
# in_discard:   The number of inbound packets which were chosen to be discarded even though no errors had been
#               detected to prevent their being deliverable to a higher-layer protocol. One possible reason for
#               discarding such a packet could be to free up buffer space.
# out_octet:    The total number of octets transmitted out of the interface, including framing characters.
# out_error:    The number of outbound packets that could not be transmitted because of errors.
# out_discard:  The number of outbound packets which were chosen to be discarded even though no errors had been
#               detected to prevent their being transmitted. One possible reason for discarding such a packet could
#               be to free up buffer space.
# ------------------------------------------------------------------------
my $oid_in_octet_table          = '1.3.6.1.2.1.2.2.1.10';    # + ".<index>"
my $oid_in_error_table          = '1.3.6.1.2.1.2.2.1.14';    # + ".<index>"
my $oid_in_discard_table        = '1.3.6.1.2.1.2.2.1.13';    # + ".<index>"
my $oid_out_octet_table         = '1.3.6.1.2.1.2.2.1.16';    # + ".<index>"
my $oid_out_error_table         = '1.3.6.1.2.1.2.2.1.20';    # + ".<index>"
my $oid_out_discard_table       = '1.3.6.1.2.1.2.2.1.19';    # + ".<index>"
# NOT USED - my $oid_in_octet_table_64  = '1.3.6.1.2.1.31.1.1.1.6';  # + ".<index>"
# NOT USED - my $oid_out_octet_table_64 = '1.3.6.1.2.1.31.1.1.1.10'; # + ".<index>"

# Cisco Specific
my $oid_cisco_type              = '.1.3.6.1.4.1.9.5.1.2.16.0'; # ex: WS-C3550-48-SMI
my $oid_cisco_serial            = '.1.3.6.1.4.1.9.5.1.2.19.0'; # ex: CAT0645Z0HB
# NOT USED - my $oid_locIfIntBitsSec = '1.3.6.1.4.1.9.2.2.1.1.6';   # need to append integer for specific interface
# NOT USED - my $oid_locIfOutBitsSec = '1.3.6.1.4.1.9.2.2.1.1.8';   # need to append integer for specific interface
# NOT USED - my $cisco_ports         = '.1.3.6.1.4.1.9.5.1.3.1.1.14.1'; # number of ports of the switch

my $oid_ifAlias                 = ".1.3.6.1.2.1.31.1.1.1.18"; # + ".<index>"

# Vlan oid per manufacturer
# ------------------------------------------------------------------------
# Cisco: ifVlan = ".1.3.6.1.4.1.9.9.68.1.2.2.1.2";
# HP:    ifVlan = ".1.3.6.1.4.1.11.2.14.11.5.1.7.1.15.1.1.1";
# ------------------------------------------------------------------------
my $oid_ifVlanName              = '.1.3.6.1.2.1.47.1.2.1.1.2'; # + ".<index>"
my $oid_ifVlanPortHP            = '.1.3.6.1.4.1.11.2.14.11.5.1.7.1.15.3.1.2'; # + ".<index>"
my $oid_ifVlanPortCisco         = '.1.3.6.1.4.1.9.9.68.1.2.2.1.2'; # + ".?.<index>"

my $oid_ipAdEntIfIndex          = ".1.3.6.1.2.1.4.20.1.2";
my $oid_ipAdEntNetMask          = ".1.3.6.1.2.1.4.20.1.3";

# ------------------------------------------------------------------------
# Other global variables
# ------------------------------------------------------------------------
my %ghOptions = ();

# ========================================================================
# FUNCTION DECLARATIONS
# ========================================================================
sub check_options();

# ========================================================================
# MAIN
# ========================================================================

# Get command line options and adapt default values in %ghOptions
check_options();

my $gInfoTable;                                      # Generated HTML code of the Info table
my $grefaInfoTableHeader = [                         # Header for the colomns of the Info table
    'Name','Uptime','System Information','Ports',
    'delta seconds used for bandwidth calculations'
    ];
if ($ghOptions{'cisco'}) { 
    # show some specific cisco info in the info table: type and serial
    splice(@$grefaInfoTableHeader,3,0,'Type');
    splice(@$grefaInfoTableHeader,4,0,'Serial');
}
    
my $grefaInfoTableData;                              # Contents of the Info table (Uptime, SysDescr, ...)

my $gInterfaceTable;                                 # Html code of the interface table
my $grefaInterfaceTableHeader = [                    # Header for the cols of the html table
    'Index','Description','Alias','AdminStatus','OperStatus','Speed',
    'Load In','Load Out','IP','bpsIn','bpsOut','Pkt errors','Last traffic','Actions'
    ];
my $grefaInterfaceTableFields = [                    # Hash keys for the content of the html table
    'index','ifDescr','ifAlias','ifAdminStatus','ifOperStatus','ifSpeedReadable',
    'ifLoadIn','ifLoadOut','IpInfo','bpsIn','bpsOut','pktErrDiscard','ifLastTraffic','actions'
    ];
if ($ghOptions{'vlan'}) { 
    # show VLANs per port
    splice(@$grefaInterfaceTableHeader,6,0,'VLANs');
    splice(@$grefaInterfaceTableFields,6,0,'ifVlanNames');
}

my $grefaInterfaceTableData;                         # Contents of the interface table (Uptime, OperStatus, ...)

my $grefaAllIndizes;                                 # Sorted array which holds all interface indexes
my $gUsedDelta                       = 0;            # time delta for bandwidth calculations (really used)

my $gInitialRun                      = 0;            # Flag that will be set if there exists no interface information file
my $gNoHistory                       = 0;            # Flag that will be set in case there's no valid historical dataset
my $gDifferenceCounter               = 0;            # Number of changes. This variable is used in the exitcode algorithm
my $gIfLoadWarnCounter               = 0;            # counter for interfaces with warning load. This variable is used in the exitcode algorithm
my $gIfLoadCritCounter               = 0;            # counter for interfaces with critical load. This variable is used in the exitcode algorithm
my $gPktErrWarnCounter               = 0;
my $gPktErrCritCounter               = 0;
my $gPktDiscardWarnCounter           = 0;
my $gPktDiscardCritCounter           = 0;
my $gNumberOfInterfaces              = 0;            # Total number of interfaces including vlans ...
my $gNumberOfFreeInterfaces          = 0;            # in "check_for_unused_interfaces" counted number of free interfaces
my $gNumberOfFreeUpInterfaces        = 0;            # in "check_for_unused_interfaces" counted number of free interfaces with status AdminUp
my $gNumberOfInterfacesWithoutTrunk  = 0;            # in "check_for_unused_interfaces" counted number of interfaces WITHOUT trunk ports
my $gInterfacesWithoutTrunk          = {};           # in "check_for_unused_interfaces" we use this for counting
my $gNumberOfPerfdataInterfaces      = 0;            # in "EvaluateInterfaces" counted number of interfaces we collect perfdata for
my $gPerfdata                        = "";           # performancedata
        # This is the base for the short and long cache timer.

my $grefaIPLines;                                    # Lines returned from snmpwalk storing ip addresses
my $grefaOperStatusLines;                            # Lines returned from snmpwalk storing ifOperStatus
my $grefaOctetInLines;                               # Lines returned from snmpwalk storing ifOctetsIn
my $grefaOctetOutLines;                              # Lines returned from snmpwalk storing ifOctetsOut
my $grefaInErrorsLines;                              # Lines returned from snmpwalk storing ifPktsInErr
my $grefaOutErrorsLines;                             # Lines returned from snmpwalk storing ifPktsOutErr
my $grefaInDiscardsLines;                            # Lines returned from snmpwalk storing ifPktsInDiscard
my $grefaOutDiscardLines;                            # Lines returned from snmpwalk storing ifPktsOutDiscard
my $gShortCacheTimer                 = 0;            # Short cache timer are calculated in ExtractCache timer routine
my $gLongCacheTimer                  = 0;            # Long cache timer are calculated in ExtractCache timer routine
my $gText;                                           # Plugin Output ...
my $gChangeText;                                     # Contains data of changes in interface properties
my $grefhSNMP;                                       # Temp snmp structure
my $grefhFile;                                       # Properties from the interface file
my $grefhCurrent;                                    # Properties from current interface states
my $grefhListOfChanges               = undef;        # List all the changes for long plugin output


# create uniq file name without extension
my $gFile =  normalize($ghOptions{'hostdisplay'}).'-Interfacetable';

# file where we store interface information table
my $gInterfaceInformationFile = "$ghOptions{'statedir'}/$gFile.txt";

# If -snapshot is set or DisableTrackingChanges is disabled on all interfaces
# we dont track changes
if (($ghOptions{'track'} and ($ghOptions{'track'}[0] eq "NONE")) or $ghOptions{'snapshot'}) {
    $gInitialRun = 1;
}

# ------------------------------------------------------------------------------
# Read data
# ------------------------------------------------------------------------------

# get uptime of the host - no caching !
$grefhCurrent->{MD}->{sysUpTime} = GetUptime ([ "$oid_sysUpTime" ],0);

# read all interfaces and its properties into the hash
$grefhFile = ReadInterfaceInformationFile ("$gInterfaceInformationFile");
logger(3, "grefhFile:".Dumper ($grefhFile));

# get sysDescr, sysName and other info for the info table. caching the long parameter
if ($ghOptions{'cisco'}) { 
    $grefhSNMP = GetMultipleDataWithSnmp ($ghOptions{'hostquery'},$ghOptions{'community'},[ "$oid_sysDescr","$oid_sysName","$oid_cisco_type","$oid_cisco_serial" ],$ghOptions{'cachedir'},$gLongCacheTimer);
    $grefhCurrent->{MD}->{sysDescr}     = "$grefhSNMP->{$oid_sysDescr}";
    $grefhCurrent->{MD}->{sysName}      = "$grefhSNMP->{$oid_sysName}";
    $grefhCurrent->{MD}->{cisco_type}   = "$grefhSNMP->{$oid_cisco_type}";
    $grefhCurrent->{MD}->{cisco_serial} = "$grefhSNMP->{$oid_cisco_serial}";
} else {
    $grefhSNMP = GetMultipleDataWithSnmp ($ghOptions{'hostquery'},$ghOptions{'community'},[ "$oid_sysDescr","$oid_sysName" ],$ghOptions{'cachedir'},$gLongCacheTimer);
    $grefhCurrent->{MD}->{sysDescr} = "$grefhSNMP->{$oid_sysDescr}";
    $grefhCurrent->{MD}->{sysName}  = "$grefhSNMP->{$oid_sysName}";
}    

# get lines with interface oper status - no caching !
$grefaOperStatusLines = GetDataWithUnixSnmpWalk ($ghOptions{'hostquery'},$ghOptions{'community'},$oid_ifOperStatus,$ghOptions{'cachedir'},0);
if ($#$grefaOperStatusLines < 0 ) {
    print "$0: Could not read ifOperStatus information from host \"$ghOptions{'hostquery'}\" with snmp\n";
    exit $ERRORS{"UNKNOWN"};
}

# -----------------------------------------------------------------
# Get lines with interface octet counters - no caching !

# -> Octets in
$grefaOctetInLines = GetDataWithUnixSnmpWalk ($ghOptions{'hostquery'},$ghOptions{'community'},$oid_in_octet_table,$ghOptions{'cachedir'},0);
if ($#$grefaOctetInLines < 0 ) {
    print "$0: Could not read ifOctetIn information from host \"$ghOptions{'hostquery'}\" with snmp\n";
    exit $ERRORS{"UNKNOWN"};
}

# -> Octets out
$grefaOctetOutLines = GetDataWithUnixSnmpWalk ($ghOptions{'hostquery'},$ghOptions{'community'},$oid_out_octet_table,$ghOptions{'cachedir'},0);
if ($#$grefaOctetOutLines < 0 ) {
    print "$0: Could not read ifOctetOut information from host \"$ghOptions{'hostquery'}\" with snmp\n";
    exit $ERRORS{"UNKNOWN"};
}

# -> Packet errors in
$grefaInErrorsLines = GetDataWithUnixSnmpWalk ($ghOptions{'hostquery'},$ghOptions{'community'},$oid_in_error_table,$ghOptions{'cachedir'},0);
if ($#$grefaInErrorsLines < 0 ) {
    print "$0: Could not read ifInErrors information from host \"$ghOptions{'hostquery'}\" with snmp\n";
    exit $ERRORS{"UNKNOWN"};
}

# -> Packet errors out
$grefaOutErrorsLines = GetDataWithUnixSnmpWalk ($ghOptions{'hostquery'},$ghOptions{'community'},$oid_out_error_table,$ghOptions{'cachedir'},0);
if ($#$grefaOutErrorsLines < 0 ) {
    print "$0: Could not read ifOutErrors information from host \"$ghOptions{'hostquery'}\" with snmp\n";
    exit $ERRORS{"UNKNOWN"};
}

# -> Packet discards in
$grefaInDiscardsLines = GetDataWithUnixSnmpWalk ($ghOptions{'hostquery'},$ghOptions{'community'},$oid_in_discard_table,$ghOptions{'cachedir'},0);
if ($#$grefaInDiscardsLines < 0 ) {
    print "$0: Could not read ifInDiscards information from host \"$ghOptions{'hostquery'}\" with snmp\n";
    exit $ERRORS{"UNKNOWN"};
}

# -> Packet discards out
$grefaOutDiscardLines = GetDataWithUnixSnmpWalk ($ghOptions{'hostquery'},$ghOptions{'community'},$oid_out_discard_table,$ghOptions{'cachedir'},0);
if ($#$grefaOutDiscardLines < 0 ) {
    print "$0: Could not read ifOutDiscards information from host \"$ghOptions{'hostquery'}\" with snmp\n";
    exit $ERRORS{"UNKNOWN"};
}

Get_TraficInOut ($grefaOctetInLines, "OctetsIn", "BitsIn");
Get_TraficInOut ($grefaOctetOutLines, "OctetsOut", "BitsOut");
Get_IfErrInOut ($grefaInErrorsLines, "PktsInErr");
Get_IfErrInOut ($grefaOutErrorsLines, "PktsOutErr");
Get_IfDiscardInOut ($grefaInDiscardsLines, "PktsInDiscard");
Get_IfDiscardInOut ($grefaOutDiscardLines, "PktsOutDiscard");


# get lines with ip addresses - no caching !
$grefaIPLines = GetDataWithUnixSnmpWalk ($ghOptions{'hostquery'},$ghOptions{'community'},$oid_ipAdEntIfIndex,$ghOptions{'cachedir'},0);

# extract ifIndex and ifOperStatus out of the lines and get the
# ifDescription from the net or from cache
Get_OperStatus_Description_Index ($grefaOperStatusLines);

# get IP Address and SubnetMask from the net or from cache
Get_IpAddress_SubnetMask ($grefaIPLines);

# get ifAdminStatus, ifSpeed and ifAlias from the net or from cache
Get_AdminStatus_Speed_Alias_Vlan ($grefhCurrent);

logger(3, " Get interface info -> generated hash\ngrefhCurrent:".Dumper ($grefhCurrent));

# ------------------------------------------------------------------------------
# Include / Exclude interfaces
# ------------------------------------------------------------------------------

# Save include/exclude information of each interface in the metadata
# This includes:
#  * include/exclude interface from load tracking. Load tracking consists in a 
#    check of the bandwidth usage of the interface. By default, all the interfaces 
#    are included in this tracking. Excluding an interface from that tracking is 
#    usually done for interfaces that we don't want any tracking (e.g. loopback 
#    interfaces)
#  * include/exclude interface from property tracking. Property tracking consists
#    in the check of any changes in the properties of an interface, properties 
#    listed via the --track option. By default, only the "operstatus" property is 
#    tracked. You have the ability to exclude/include some interfaces from that check.
#    This would be done for exemple for ports on which printers are connected (indeed, 
#    some printers going in standby mode has also their network interface going done, 
#    generating a false alert)

$grefhCurrent = EvaluateInterfaces (
    $ghOptions{'exclude-traffic'},
    $ghOptions{'include-traffic'},
    $ghOptions{'exclude-property'},
    $ghOptions{'include-property'}
    );
logger(3, " Interface inclusions / exclusions -> generated hash\ngrefhCurrent:".Dumper ($grefhCurrent));

# ------------------------------------------------------------------------------
# Create interface information table data
# ------------------------------------------------------------------------------

# sort ifIndex by number
@$grefaAllIndizes = sort { $a <=> $b }
    keys (%{$grefhCurrent->{MD}->{IfIndexTable}->{ByIndex}});
logger(3, " Interface information table data -> generated array\ngrefaAllIndizes:".Dumper ($grefaAllIndizes));

my $basetime = CleanAndSelectHistoricalDataset();
if (defined $basetime) {
    CalculateBps($basetime);
    EvaluatePackets($basetime);
} else {
    $gNoHistory = 1;
}

# ------------------------------------------------------------------------------
# write perfdata stdout and files
# ------------------------------------------------------------------------------
if ( $gNumberOfPerfdataInterfaces > 0 and not $gInitialRun and $ghOptions{'enableperfdata'}) {
    perfdataout();
}

# ------------------------------------------------------------------------------
# write interface information file
# ------------------------------------------------------------------------------

# first run - the hash from the file is empty because we had no file before
# fill it up with all interface intormation and with the index tables
#
# we take a separate field where we remember the last reset
# of the entire file
if (not $grefhFile->{TableReset}) {
    $grefhFile->{TableReset} = scalar localtime time ();
    $grefhFile->{If} = $grefhCurrent->{If};
    logger(1, " (Debug) Initial run -> $grefhFile->{TableReset}");
}

# Fill up the MD tree (MD = MetaData) - here we store all variable
# settings
$grefhFile->{MD} = $grefhCurrent->{MD};

# ------------------------------------------------------------------------------
# write interface information file
# ------------------------------------------------------------------------------

WriteConfigFileNew ("$gInterfaceInformationFile",$grefhFile);

# ------------------------------------------------------------------------------
# STDOUT
# ------------------------------------------------------------------------------

# If there are changes in the table write it to stdout
if ($gChangeText) {
    $gText = $gChangeText . "$gNumberOfInterfacesWithoutTrunk interface(s)";
} else {
    $gText = "$gNumberOfInterfacesWithoutTrunk interface(s)"
}

#logger(3, "gInterfacesWithoutTrunk: " . Dumper (%{$gInterfacesWithoutTrunk}));
for my $switchport (keys %{$gInterfacesWithoutTrunk}) {
    if ($gInterfacesWithoutTrunk->{$switchport}) {
        # this port is free
        $gNumberOfFreeInterfaces++
    }
}
#TODO go critical...
if ( $gNumberOfFreeInterfaces >= 0 ) {
    logger(1, "---->>> ports: $gNumberOfInterfacesWithoutTrunk, free: $gNumberOfFreeInterfaces");
    $gText .= ", $gNumberOfFreeInterfaces free";
}

if ( $gNumberOfFreeUpInterfaces > 0 ) {
    $gText .= ", $gNumberOfFreeUpInterfaces AdminUp and free";
}

if ( $gNumberOfPerfdataInterfaces > 0 and $ghOptions{'enableperfdata'}) {
    $gText .= ", $gNumberOfPerfdataInterfaces graphed";         # thd
}

# ------------------------------------------------------------------------------
# Create host information table data
# ------------------------------------------------------------------------------

$grefaInfoTableData->[0]->[0]->{Value} = "$grefhCurrent->{MD}->{sysName}";
$grefaInfoTableData->[0]->[1]->{Value} = TimeDiff (1,$grefhCurrent->{MD}->{sysUpTime} / 100); # start at 1 because else we get "NoData"
$grefaInfoTableData->[0]->[2]->{Value} = "$grefhCurrent->{MD}->{sysDescr}";
if ($ghOptions{'cisco'}) {
    $grefaInfoTableData->[0]->[3]->{Value} = "$grefhCurrent->{MD}->{cisco_type}";
    $grefaInfoTableData->[0]->[4]->{Value} = "$grefhCurrent->{MD}->{cisco_serial}";
    $grefaInfoTableData->[0]->[5]->{Value} = "ports:&nbsp;$gNumberOfInterfacesWithoutTrunk free:&nbsp;$gNumberOfFreeInterfaces";
    $grefaInfoTableData->[0]->[5]->{Value} .= " AdminUpFree:&nbsp;$gNumberOfFreeUpInterfaces";
    if ($ghOptions{'delta'}) {$grefaInfoTableData->[0]->[6]->{Value} = "$ghOptions{'delta'}" }
    else { $grefaInfoTableData->[0]->[6]->{Value} =  'no data to compare with'; }
} else {
    $grefaInfoTableData->[0]->[3]->{Value} = "ports:&nbsp;$gNumberOfInterfacesWithoutTrunk free:&nbsp;$gNumberOfFreeInterfaces";
    $grefaInfoTableData->[0]->[3]->{Value} .= " AdminUpFree:&nbsp;$gNumberOfFreeUpInterfaces";
    if ($ghOptions{'delta'}) {$grefaInfoTableData->[0]->[4]->{Value} = "$ghOptions{'delta'}" }
    else { $grefaInfoTableData->[0]->[4]->{Value} =  'no data to compare with'; }
}

#
# Generate Html Table
# do not compare ifDescr and ifIndex because they can change during reboot
# Field list: index,ifDescr,ifAlias,ifAdminStatus,ifOperStatus,ifSpeedReadable,ifVlanNames,ifLoadIn,ifLoadOut,IpInfo,bpsIn,bpsOut,ifLastTraffic
#
$grefaInterfaceTableData = GenerateHtmlTable ($grefaInterfaceTableFields,$ghOptions{track});

# ------------------------------------------------------------------------------
# Create HTML tables
# ------------------------------------------------------------------------------

my $EndTime = time ();
my $TimeDiff = $EndTime-$STARTTIME;

# If current run is the first run we dont compare data
if ( $gInitialRun ) {
    logger(1, " (Debug) Initial run -> Setting DifferenceCounter to zero.");
    $gDifferenceCounter = 0;
    #$gText = "$gNumberOfInterfacesWithoutTrunk interface(s)";
    $gText = "Initial run...";    
} elsif ( $gNoHistory ){
    logger(1, " (Debug) Initial run -> Setting DifferenceCounter to zero.");
    $gDifferenceCounter = 0;
    $gText = "No valid historical dataset...";        
} else {
    logger(1, " (Debug) Differences: $gDifferenceCounter");
    if ($gDifferenceCounter > 0) { 
        if ($ghOptions{'outputshort'}) { 
            $gText .= ", $gDifferenceCounter change(s)";
        } else {
            $gText .= ", $gDifferenceCounter change(s):";
            for my $field ( keys %{$grefhListOfChanges} ) {
                if (not $field =~ /^load|^warning-pkterr$|^critical-pkterr$|^warning-pktdiscard$|^critical-pktdiscard$/i) {
                    $gText .= " $field - @{$grefhListOfChanges->{$field}}";
                }
            }
        }
    }
}

# Create "small" information table
$gInfoTable = Csv2Html ($grefaInfoTableHeader,$grefaInfoTableData,"infotable");

# Create "big" interface table
$gInterfaceTable   = Csv2Html ($grefaInterfaceTableHeader,$grefaInterfaceTableData,"interfacetable");

# ------------------------------------------------------------------------------
# Calculate exitcode and exit this program
# ------------------------------------------------------------------------------

# $gDifferenceCounter contains the number of changes which
# were made in the interface configurations
my $ExitCode = mcompare ({
    Value       => $gDifferenceCounter,
    Warning     => $ghOptions{'warning-property'},
    Critical    => $ghOptions{'critical-property'}
});

#if ($gNumberOfFreeUpInterfaces > 0) {
#    $ExitCode = $ERRORS{'WARNING'} if ($ExitCode ne $ERRORS{'CRITICAL'});
#}

# Load
if ($gIfLoadWarnCounter > 0 ) {
    $ExitCode = $ERRORS{'WARNING'} if ($ExitCode ne $ERRORS{'CRITICAL'});
    if ($ghOptions{'outputshort'}) {
        $gText .= ", load warning (>$ghOptions{'warning-load'}%): $gIfLoadWarnCounter";
    } else {
        $gText .= ", $gIfLoadWarnCounter warning load(s) (>$ghOptions{'warning-load'}%): @{$grefhListOfChanges->{loadwarning}}";
    }
}
if ($gIfLoadCritCounter > 0 ) {
    $ExitCode = $ERRORS{'CRITICAL'};
    if ($ghOptions{'outputshort'}) {
        $gText .= ", load critical (>$ghOptions{'critical-load'}%): $gIfLoadCritCounter";
    } else {
        $gText .= ", $gIfLoadCritCounter critical load(s) (>$ghOptions{'critical-load'}%): @{$grefhListOfChanges->{loadcritical}}";
    }
}

# Packet errors
if ($gPktErrWarnCounter > 0 ) {
    $ExitCode = $ERRORS{'WARNING'} if ($ExitCode ne $ERRORS{'CRITICAL'});
    if ($ghOptions{'outputshort'}) {
        $gText .= ", error pkts/s warning (>$ghOptions{'warning-pkterr'}): $gPktErrWarnCounter";
    } else {
        $gText .= ", $gPktErrWarnCounter warning error pkts/s (>$ghOptions{'warning-pkterr'}): @{$grefhListOfChanges->{'warning-pkterr'}}";
    }
}

if ($gPktErrCritCounter > 0 ) {
    $ExitCode = $ERRORS{'CRITICAL'};
    if ($ghOptions{'outputshort'}) {
        $gText .= ", error pkts/s critical (>$ghOptions{'critical-pkterr'}): $gPktErrCritCounter";
    } else {
        $gText .= ", $gPktErrCritCounter critical error pkts/s (>$ghOptions{'critical-pkterr'}): @{$grefhListOfChanges->{'critical-pkterr'}}";
    }
}

# Packet discards
if ($gPktDiscardWarnCounter > 0 ) {
    $ExitCode = $ERRORS{'WARNING'} if ($ExitCode ne $ERRORS{'CRITICAL'});
    if ($ghOptions{'outputshort'}) {
        $gText .= ", discard pkts/s warning (>$ghOptions{'warning-pktdiscard'}): $gPktDiscardWarnCounter";
    } else {
        $gText .= ", $gPktDiscardWarnCounter discard pkts/s (>$ghOptions{'warning-pktdiscard'}): @{$grefhListOfChanges->{'warning-pktdiscard'}}";
    }
}

if ($gPktDiscardCritCounter > 0 ) {
    $ExitCode = $ERRORS{'CRITICAL'};
    if ($ghOptions{'outputshort'}) {
        $gText .= ", discard pkts/s critical (>$ghOptions{'critical-pktdiscard'}): $gPktDiscardCritCounter";
    } else {
        $gText .= ", $gPktDiscardCritCounter discard pkts/s (>$ghOptions{'critical-pktdiscard'}): @{$grefhListOfChanges->{'critical-pktdiscard'}}";
    }
}

# Append html table link to text
$gText = AppendLinkToText({
          Text        => $gText,
          HtmlUrl     => $ghOptions{'htmltableurl'},
          File        => "$gFile.html"
        });

if ($ghOptions{'cisco'} and $grefhCurrent->{MD}->{cisco_type} and $grefhCurrent->{MD}->{cisco_serial}) {
    $gText = "$grefhCurrent->{MD}->{cisco_type} ($grefhCurrent->{MD}->{cisco_serial}): ". $gText;
}

# Write Html Table
WriteHtmlTable ({
    Header      => $gInfoTable,
    Body        => $gInterfaceTable,
    Dir         => $ghOptions{'htmltabledir'},
    FileName    => "$ghOptions{'htmltabledir'}/$gFile".'.html'
});

# Print Text and exit with the correct exitcode
ExitPlugin ({
    ExitCode    =>  $ExitCode,
    Text        =>  $gText,
    Fields      =>  $gDifferenceCounter
});

# This code should never be reached
exit $ERRORS{"UNKNOWN"};

# ------------------------------------------------------------------------
#      MAIN ENDS HERE
# ------------------------------------------------------------------------

# ------------------------------------------------------------------------
# write performance data
# perfdataout ();
# ------------------------------------------------------------------------
sub perfdataout {
    my %gh_operstatus = ('up'=>1,'down'=>2,'testing'=>3,'unknown'=>4,'dormant'=>5);
    if ($ghOptions{perfdatadir}) { # perfdata to file
        my $filename = $ghOptions{perfdatadir} . "/service-perfdata.$STARTTIME";
        umask "$UMASK";
        open (OUT,">>$filename") or die "cannot open $filename $!";
        flock (OUT, 2) or die "cannot flock $filename ($!)"; # get exclusive lock;
        }
    # $grefaAllIndizes is a indexed and sorteted list of all interfaces
    for my $InterfaceIndex (@$grefaAllIndizes) {
        # Get normalized interface name (key for If data structure)
        my $oid_ifDescr = $grefhCurrent->{MD}->{IfIndexTable}->{ByIndex}->{$InterfaceIndex};

        if ($grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedLoadTrack} eq "false" 
            and defined $grefhCurrent->{MD}->{IfIndexTable}->{OctetsIn}->{$InterfaceIndex}) {
            my $port = sprintf("%03d", $InterfaceIndex);
            #my $servicename = "Port$port";
            my $servicename = "If_" . trim(denormalize($grefhCurrent->{MD}->{IfIndexTable}->{ByIndex}->{$InterfaceIndex}));
            $servicename =~ s/[: ]/_/g;
            $servicename =~ s/[()]//g;
            #my $servicename = 'Interface - ' . trim(denormalize($grefhCurrent->{MD}->{IfIndexTable}->{ByIndex}->{$InterfaceIndex}));
            my $perfdata = "";
            #Add interface status if available
            if (defined $grefhCurrent->{MD}->{IfIndexTable}->{OperStatus}->{$InterfaceIndex}) {
                if ($ghOptions{'portperfunit'} eq "octet") {
                        $perfdata .= "${servicename}::check_interface_table_port_octet::" . # servicename::plugin
                                "OperStatus=".$gh_operstatus{"$grefhCurrent->{MD}->{IfIndexTable}->{OperStatus}->{$InterfaceIndex}"}.";;;0; " .
                                "OctetsIn=$grefhCurrent->{MD}->{IfIndexTable}->{OctetsIn}->{$InterfaceIndex}c;;;0; " .
                                "OctetsOut=$grefhCurrent->{MD}->{IfIndexTable}->{OctetsOut}->{$InterfaceIndex}c;;;0; ";
                } else {
                        $perfdata .= "${servicename}::check_interface_table_port_bit::" . # servicename::plugin
                                "OperStatus=".$gh_operstatus{"$grefhCurrent->{MD}->{IfIndexTable}->{OperStatus}->{$InterfaceIndex}"}.";;;0; " .
                                "BitsIn=$grefhCurrent->{MD}->{IfIndexTable}->{BitsIn}->{$InterfaceIndex}c;;;0; " .
                                "BitsOut=$grefhCurrent->{MD}->{IfIndexTable}->{BitsOut}->{$InterfaceIndex}c;;;0; ";
                }
                #Add pkt errors/discards if available
                if (defined $grefhCurrent->{MD}->{IfIndexTable}->{PktsInErr}->{$InterfaceIndex}) {
                    $perfdata .= "PktsInErr=$grefhCurrent->{MD}->{IfIndexTable}->{PktsInErr}->{$InterfaceIndex}c;;;0; " .
                                "PktsOutErr=$grefhCurrent->{MD}->{IfIndexTable}->{PktsOutErr}->{$InterfaceIndex}c;;;0; " .
                                "PktsInDiscard=$grefhCurrent->{MD}->{IfIndexTable}->{PktsInDiscard}->{$InterfaceIndex}c;;;0; " .
                                "PktsOutDiscard=$grefhCurrent->{MD}->{IfIndexTable}->{PktsOutDiscard}->{$InterfaceIndex}c;;;0; ";
                }
            }
            
            logger(1, "collected perfdata: $oid_ifDescr\t$perfdata");
            if ($ghOptions{perfdatadir}) { # perfdata to file
                #TODO: make it atomic (ie rename after write) and use a save filename
                print OUT "$grefhCurrent->{MD}->{sysName}\t";  # hostname
                print OUT "$servicename";                      # servicename
                print OUT "\t\t";                              # pluginoutput
                print OUT "$perfdata";                         # performancedata
                print OUT "\t$STARTTIME\n";                   # unix timestamp
                        }

            if($ghOptions{'enableperfdata'}){$gPerfdata .= " $perfdata"; }      # thd collect performancedata
        }
    } # for $InterfaceIndex
    if (defined $ghOptions{perfdatadir}) { # perfdata to file
        close (OUT);
        }
    return 0;
}

# ------------------------------------------------------------------------
# Create interface table html table file
# This file will be visible on the browser
#
# WriteHtmlTable ({
#    Header      => $gInfoTable,
#    Body        => $gInterfaceTable,
#    FileName    => $gHtmlFileName
# });
#
# ------------------------------------------------------------------------
sub WriteHtmlTable {

    my $refhStruct = shift;

    my $Footer = HtmlLinks ({
        Back            =>  1,
        ResetTable      =>  "$gInterfaceInformationFile"
    });

    umask "$UMASK";

                not -d $refhStruct->{Dir} and MyMkdir($refhStruct->{Dir});

    open (OUT,">$refhStruct->{FileName}") or die "cannot $refhStruct->{FileName} $!";
        print OUT '
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <title>' . $grefhCurrent->{MD}->{sysName} . '</title>
    <link rel="stylesheet" type="text/css" href="../css/' . $css_stylesheet . '">
	<script type="text/javascript" src="../js/functions.js"></script>
  </head>
<body>
';
        print OUT '<center><pre><a href="' . $ghOptions{'accessmethod'} . '://',$ghOptions{'hostquery'},'">',$ghOptions{'hostquery'},'</a>',
            ' updated: ',scalar localtime $EndTime,' (',$EndTime-$STARTTIME,' sec.)</pre>';
        print OUT $refhStruct->{Header};
        print OUT $refhStruct->{Body};
        print OUT $Footer;
        print OUT '<center></body></html>';
    close (OUT);
    logger(1, "HTML table file created: $refhStruct->{FileName}");
    return 0;
}

# ------------------------------------------------------------------------
# Purpose:
#   calc exit code
# ------------------------------------------------------------------------
sub mcompare {

    my $refhStruct = shift;

    my $ExitCode = $ERRORS{"OK"};

    $refhStruct->{Warning} and $refhStruct->{Value} >= $refhStruct->{Warning}
        and $ExitCode = $ERRORS{"WARNING"};

    $refhStruct->{Critical} and $refhStruct->{Value} >= $refhStruct->{Critical}
        and $ExitCode = $ERRORS{"CRITICAL"};

    return $ExitCode;
}

# ------------------------------------------------------------------------
# Compare data from refhFile and refhCurrent and create the csv data for
# html table.
# ------------------------------------------------------------------------
sub GenerateHtmlTable {

    my $refaFields               = shift;               # Array of the fields for the table
    my $refaToCompare            = shift;               # Array of fields which should be included from change tracking
    my $iLineCounter             = 0;                   # Fluss Variable (ah geh ;-) )
    my $refaContentForHtmlTable;                        # This is the final data structure which we pass to csv2htmlnew
    my $DataForMD5CheckSum       = "";                  # MD5 Checksum

    # Print a header for debug information
    logger(1, "x"x50);
    
    # Print tracking info
    logger(3, "Available fields:".Dumper($refaFields));
    logger(3, "Tracked fields:".Dumper($refaToCompare));
    
    # $grefaAllIndizes is a indexed and sorteted list of all interfaces
    for my $InterfaceIndex (@$grefaAllIndizes) {

        # Current field ID
        my $iFieldCounter = 0;

        # Get normalized interface name (key for If data structure)
        my $oid_ifDescr = $grefhCurrent->{MD}->{IfIndexTable}->{ByIndex}->{$InterfaceIndex};

        # This is the If datastructure from the interface information file
        my $refhInterFaceDataFile     = $grefhFile->{If}->{$oid_ifDescr};

        # This is the current measured If datastructure
        my $refhInterFaceDataCurrent  = $grefhCurrent->{If}->{$oid_ifDescr};

        # This variable used for exittext
        $gNumberOfInterfaces++;

        for my $FieldName ( @$refaFields ) {

            my $ChangeTime;
            my $LastChangeInfo          = "";
            #my $CellColor;
            my $CellBackgroundColor;
			my $CellStyle;
            my $CellContent;
            my $CurrentFieldContent     = "";
            my $FileFieldContent        = "";
            my $FieldType               = "";
            
            if ($FieldName =~ /^index$|^ifDescr$|^ifAlias$|^ifAdminStatus$|^ifOperStatus$|^ifSpeedReadable$|^ifVlanNames$|^IpInfo$/i) {
                $FieldType = "property";
            } elsif ( $FieldName =~ /^ifLoadIn$|^ifLoadOut$|^bpsIn$|^bpsOut$|^ifLastTraffic$/i ) {
                $FieldType = "load";
            }
            
            if (defined $refhInterFaceDataCurrent->{"$FieldName"}) {
                # This is used to calculate the id (used for displaying the html table)
                $DataForMD5CheckSum .= $refhInterFaceDataCurrent->{"$FieldName"};
                $CurrentFieldContent  = $refhInterFaceDataCurrent->{"$FieldName"};
                # Delete the first and last "blank"
                $CurrentFieldContent =~ s/^ //;
                $CurrentFieldContent =~ s/ $//;
            }
            if (defined $refhInterFaceDataFile->{"$FieldName"}) {
                $FileFieldContent = $refhInterFaceDataFile->{"$FieldName"};
            }

            # Flag if the current status of this field should be compared with the
            # "snapshoted" status.
            my $CompareThisField = grep (/$FieldName/i, @$refaToCompare);

            # some fields have a change time property in the interface information file.
            # if the change time exists we store this and write into html table
            $ChangeTime = $grefhFile->{MD}->{If}->{$oid_ifDescr}->{$FieldName."ChangeTime"};

            # If interface is excluded or this is the initial run we don't lookup for
            # data changes
            if ($gInitialRun)  {
                $CompareThisField = 0;
				$CellStyle = "cellInitialRun";
            } elsif ($grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedLoadTrack} eq "true") {
                $CompareThisField = 0;
				$CellStyle = "cellExcluded";
            } elsif (($grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedPropertyTrack} eq "true") && ( $FieldType eq "property" )) {
                $CompareThisField = 0;
				$CellStyle = "cellNotTracked";
            } elsif (defined $grefhCurrent->{If}->{$oid_ifDescr}->{$FieldName."OutOfRange"}) {
                $CellBackgroundColor = $grefhCurrent->{If}->{$oid_ifDescr}->{$FieldName."OutOfRange"};
            }
            
            # Set LastChangeInfo to this Format "(since 0d 0h 43m)"
            if ( defined $ChangeTime and $ghOptions{trackduration} ) {
                $ChangeTime = TimeDiff ("$ChangeTime",time());
                $LastChangeInfo = "(since $ChangeTime)";
            }

            if ( $CompareThisField  ) {
                logger(1, "Compare \"".denormalize($oid_ifDescr)."($FieldName)\" now=\"$CurrentFieldContent\" file=\"$FileFieldContent\"");
                if ( $CurrentFieldContent eq $FileFieldContent ) {
                    # Field content has NOT changed
                    $CellContent = denormalize ( $CurrentFieldContent );
                    $CellStyle = "cellTrackedOk";
                } else {
                    # Field content has changed ...
                    $CellContent = "now: " . denormalize( $CurrentFieldContent ) . "$LastChangeInfo was: " . denormalize ( $FileFieldContent );
                    if ($ghOptions{verbose} or $ghOptions{warning} > 0 or $ghOptions{critical} > 0) {
                        $gChangeText .= "(" . denormalize ($oid_ifDescr) .
                            ") $FieldName now <b>$CurrentFieldContent</b> (was: <b>$FileFieldContent</b>)<br>";
                    }
                    $CellStyle = "cellTrackedChange";
                    $gDifferenceCounter++;
                    
                    # Update the list of changes
                    push @{$grefhListOfChanges->{"$FieldName"}}, trim(denormalize($oid_ifDescr));
                }
            } else {
                # Filed will not be compared, just write the current field - value in the table.
                logger(1, "Not comparing $FieldName on interface ".denormalize($oid_ifDescr));
                $CellContent = denormalize( $CurrentFieldContent );
            }

            # Write an empty cell content if CellContent is empty
            # This is for visual purposes
            not $CellContent and $CellContent = '&nbsp';

            # Actions field
            if (grep (/$FieldName/i, "Actions")) {
                # Graphing solution link - one link per line/interface/port
                if ($grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedLoadTrack} eq "false" 
                    and defined $grefhCurrent->{MD}->{IfIndexTable}->{OctetsIn}->{$InterfaceIndex}
                    and $ghOptions{'enableperfdata'}) {
                        #my $servicename = 'Port' . sprintf("%03d", $InterfaceIndex);
                        my $servicename = "If_" . trim(denormalize($oid_ifDescr));
                        $servicename =~ s/#/%23/g;
                        $servicename =~ s/:/_/g;
                        $servicename =~ s/[()]//g;
                        if ($ghOptions{'grapher'} eq  "pnp4nagios") {
                            $CellContent .= '<a href="' . 
                                           $ghOptions{'grapherurl'} . '/graph?host=' . $ghOptions{'hostdisplay'} . '&srv=' . $servicename .
                                           '"><img src="' .
                                           '../img/chart.png' .
                                           '" alt="Trends" /></a>&nbsp';
                        } elsif ($ghOptions{'grapher'} eq  "nagiosgrapher" or $ghOptions{'grapher'} eq  "netwaysgrapherv2") {
                            $refaContentForHtmlTable->[ $iLineCounter ]->[ $iFieldCounter ]->{InterfaceGraphURL} = 
                                $ghOptions{'grapherurl'} . '/graphs.cgi?host=' . $grefhCurrent->{MD}->{sysName} . '&service=' . $servicename . '&page_act=1+traffic';
                        }
                }
                # Retrieve detailed interface info via snmp link
                if ($feature_interfaceInfoDetail and $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedLoadTrack} eq "false") {
                    $CellContent .= '<a href="xxxxxxxxxxxx.cgi?' . 
                                   'host=' . $ghOptions{'hostquery'} . 
                                   '&ifindex=' . $InterfaceIndex .
                                   '"><img src="' .
                                   '../img/binocular.png' .
                                   '" alt="Details" /></a>&nbsp';
                }
            }
            
            # Store cell content in table
            $refaContentForHtmlTable->[ $iLineCounter ]->[ $iFieldCounter ]->{"Value"} = "$CellContent";

            # Change font color
            #  defined $CellColor and
            #  $refaContentForHtmlTable->[ $iLineCounter ]->[ $iFieldCounter ]->{Font} =
            #  $CellColor;
            # Change background color
            defined $CellBackgroundColor and
              $refaContentForHtmlTable->[ $iLineCounter ]->[ $iFieldCounter ]->{Background} = $CellBackgroundColor;
			# Change cell style
            defined $CellStyle and
              $refaContentForHtmlTable->[ $iLineCounter ]->[ $iFieldCounter ]->{Style} = $CellStyle;

            $iFieldCounter++;
        } # for FieldName
        
        $iLineCounter++;
    } # for $InterfaceIndex

    # Print a footer for debug information
    logger(3, " List of changes -> generated hash of array\ngrefhListOfChanges:".Dumper ($grefhListOfChanges));
    logger(1, "x"x50);

    return $refaContentForHtmlTable;
}

# ------------------------------------------------------------------------
# This function includes or excludes interfaces from:
#  * interface traffic load tracking
#  * interface property(ies) change tracking
#
# Interface traffic load tracking:
# All interfaces which are excluded using -e or --exclude-traffic will be
# excluded from traffic measurement (main check). Property(ies) tracking is
# implicitely disabled on such an interface.
#
# Interface property(ies) change tracking
# All the interfaces which are included in the traffic load tracking are 
# automatically added to the interface properti(es) tracking list.
#
#   Indicated must be the interface name (ifDescr)
#   -e "3COM Etherlink PCI"
#
#   It is possible to exclude all interfaces
#   -e "ALL"
#
#   It is possible to exclude all interfaces but include one
#   -e "ALL" -i "3COM Etherlink PCI"
#
# It isnt neccessary to include ALL. By default, all the interfaces are 
# included.
#
# The interface information file will be altered as follows:
#
# <MD>
#    <If>
#        <3COMQ20EtherlinkQ20PCI>
#            CacheTimer               3600
#            ExcludedLoadTrack        false
#            ExcludedPropertyTrack    true
#            ifOperStatusChangeTime   1151586678
#        </3COMQ20EtherlinkQ20PCI>
#    </If>
# </MD>
#
# ------------------------------------------------------------------------
sub EvaluateInterfaces {

    my $ExcludeLoadTrackList = shift;
    my $IncludeLoadTrackList = shift;
    my $ExcludePropertyTrackList = shift;
    my $IncludePropertyTrackList = shift;

    logger(1, "ExcludeLoadTrackList:\n".Dumper($ExcludeLoadTrackList));
    logger(1, "IncludeLoadTrackList:\n".Dumper($IncludeLoadTrackList));
    logger(1, "ExcludePropertyTrackList:\n".Dumper($ExcludePropertyTrackList));
    logger(1, "IncludePropertyTrackList:\n".Dumper($IncludePropertyTrackList));
    
    # Loop through all interfaces
    for my $oid_ifDescr (keys %{$grefhCurrent->{MD}->{If}}) {

        #----- Includes or excludes interfaces from traffic load tracking -----#
        
        # Denormalize interface name
        my $oid_ifDescrReadable = denormalize ($oid_ifDescr);
        my $oid_ifAliasReadable = denormalize ($grefhCurrent->{If}->{"$oid_ifDescr"}->{ifAlias});
        
        # By default, don't exclude the interface
        $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedLoadTrack} = "false";
        
        # Process the interface exclusion list
        for my $ExcludeString (@$ExcludeLoadTrackList) {
            if ($ghOptions{regexp}) {
                if ("$oid_ifDescrReadable" =~ /$ExcludeString/i or "$ExcludeString" eq "ALL") {
                    logger(1, "-- exclude ($ExcludeString) interface \"$oid_ifDescrReadable\"");
                    $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedLoadTrack} = "true";
                }
            }
            elsif ("$oid_ifDescrReadable" eq "$ExcludeString" or "$ExcludeString" eq "ALL") {
                logger(1, "-- exclude ($ExcludeString) interface \"$oid_ifDescrReadable\"");
                $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedLoadTrack} = "true";
            }
        }

        # Process the interface inclusion list
        # Inclusions are done after exclusions to be able to include a 
        # subset of a group of interfaces which were excluded previously
        for my $IncludeString (@$IncludeLoadTrackList) {
            if ($ghOptions{regexp}) {
                if ("${oid_ifDescrReadable}_${oid_ifAliasReadable}" =~ /$IncludeString/i or "$IncludeString" eq "ALL") {
                    logger(1, "+ include ($IncludeString) interface \"$oid_ifDescrReadable\"");
                    $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedLoadTrack} = "false";
                }
            }
            elsif ("$oid_ifDescrReadable" eq "$IncludeString" or "$oid_ifAliasReadable" eq "$IncludeString" or "$IncludeString" eq "ALL") {
                logger(1, "+ include ($IncludeString) interface \"$oid_ifDescrReadable\"");
                $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedLoadTrack} = "false";
            }
        }
      
        # Update the counter if needed        
        if ($grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedLoadTrack} eq "false") {
            $gNumberOfPerfdataInterfaces++;
        }
        
        #----- Includes or excludes interfaces from property change tracking -----#
        
		# For the interfaces included (for which the traffic load is tracked), enable property(ies) tracking depending on the exclude and/or include property tracking port list
        if ($grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedLoadTrack} eq "false") {
            
            # By default, track the properties of the interface
            $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedPropertyTrack} = "false";
            
            # Process the interface exclusion list
            for my $ExcludeString (@$ExcludePropertyTrackList) {
                if ($ghOptions{regexp}) {
                    if ("$oid_ifDescrReadable" =~ /$ExcludeString/i or "$ExcludeString" eq "ALL") {
                        logger(1, "-- exclude ($ExcludeString) interface \"$oid_ifDescrReadable\"");
                        $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedPropertyTrack} = "true";
                    }
                }
                elsif ("$oid_ifDescrReadable" eq "$ExcludeString" or "$ExcludeString" eq "ALL") {
                    logger(1, "-- exclude ($ExcludeString) interface \"$oid_ifDescrReadable\"");
                    $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedPropertyTrack} = "true";
                }
            }
    
            # Process the interface inclusion list
            # Inclusions are done after exclusions to be able to include a 
            # subset of a group of interfaces which were excluded previously
            for my $IncludeString (@$IncludePropertyTrackList) {
                if ($ghOptions{regexp}) {
                    if ("${oid_ifDescrReadable}_${oid_ifAliasReadable}" =~ /$IncludeString/i or "$IncludeString" eq "ALL") {
                        logger(1, "+ include ($IncludeString) interface \"$oid_ifDescrReadable\"");
                        $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedPropertyTrack} = "false";
                    }
                }
                elsif ("$oid_ifDescrReadable" eq "$IncludeString" or "$oid_ifAliasReadable" eq "$IncludeString" or "$IncludeString" eq "ALL") {
                    logger(1, "+ include ($IncludeString) interface \"$oid_ifDescrReadable\"");
                    $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedPropertyTrack} = "false";
                }
            }
            
        } else {
            $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{ExcludedPropertyTrack} = "true";
        }
        
    } # for each interface
    return $grefhCurrent;
}

# ------------------------------------------------------------------------
# Get the uptime of the remote system and store timeticks in raw format
# (not translated into human readable format)
# ------------------------------------------------------------------------
sub GetUptime {
    my $refaOID     = shift;
    my $CacheTimer  = shift;

    my $Value = SnmpGetV1 ({
        -hostname   => "$ghOptions{'hostquery'}",
        -community  => "$ghOptions{'community'}",
        -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
        OID         => $refaOID,
        CacheDir    => "$ghOptions{'cachedir'}",
        CacheTimer  => int rand ($CacheTimer),
    });

    # we got data
    if ($Value) {
        return $Value;
    } else {
        # und tschuess - hat keinen Sinn weiter zu machen
        print "$0: Could not read sysUpTime information from host \"$ghOptions{hostquery}\" with snmp\n";
#TODO get from cache to enrich error text
# $oid_cisco_type   = '.1.3.6.1.4.1.9.5.1.2.16.0'; # WS-C3550-48-SMI
# $oid_cisco_serial = '.1.3.6.1.4.1.9.5.1.2.19.0'; # CAT0645Z0HB
        exit $ERRORS{"CRITICAL"};
    }
}

# ------------------------------------------------------------------------
# get ifOperStatus, ifDescr and ifIndex
# ------------------------------------------------------------------------
sub Get_OperStatus_Description_Index {

    my $refaOperStatusLines = shift;

    # Example of $refaOperStatusLines
    #    .1.3.6.1.2.1.2.2.1.8.1 up
    #    .1.3.6.1.2.1.2.2.1.8.2 down
    for (@$refaOperStatusLines) {
        my ($Index,$OperStatusNow) = split / /,$_,2;
        $Index =~ s/^.*\.//g;           # remove all but the index
        $OperStatusNow =~ s/\s+$//g;    # remove invisible chars from the end
        $OperStatusNow = ConvertIfStatusToReadable("$OperStatusNow"); 
        
        logger(1, "Index = $Index $gLongCacheTimer");
        # read the interface description with the index extracted above
        my $Desc = GetDataWithSnmp ($ghOptions{'hostquery'},$ghOptions{'community'},[ "$oid_ifDescr.$Index" ],$ghOptions{'cachedir'},$gLongCacheTimer);

        # check an empty interface description and add a new description
        # this occurs on some devices (e.g. HP procurve switches)
        if ("$Desc" eq "") {
            # read the MAC address of the interface - independend if it has one or not
            my $MacAddress = GetDataWithSnmp ($ghOptions{'hostquery'},$ghOptions{'community'},[ "$oid_ifPhysAddress.$Index" ],$ghOptions{'cachedir'},$gShortCacheTimer);
            $Desc = "($MacAddress)";
            logger(1, "Interface with index $Index has no description.\nSet it to $Desc");
        }

        # normalize the interface description to not get into trouble
        # with special characters and how Config::General handles blanks
        $Desc = normalize ($Desc);

        # on some operating systems there could be interfaces with
        # the same name - check this out - append uniq text at the end to
        # get a uniq interface name
        if ($grefhCurrent->{If}->{"$Desc"}) {
            my $Text; # dummy text for uniq if description

            # read the MAC address of the interface
            my $MacAddress = GetDataWithSnmp ($ghOptions{'hostquery'},$ghOptions{'community'},[ "$oid_ifPhysAddress.$Index" ],$ghOptions{'cachedir'},$gShortCacheTimer);

            # check if we got back a MAC Address - otherwise take the interface
            # index - this could only lead to problems where index is changed
            # during reboot and duplicate interface names
            if ($MacAddress) {
                $Text = "(${MacAddress})";
            } else {
                $Text = "(${Index})";
            }
            logger(1, "Duplicate if ($Index) name - \"$Text\"");

            # append a blank (normalized) the MAC Address or the index
            # to the end of the description
            $Desc = "${Desc}Q20".normalize($Text);
        }

        # Store the oper status as property of the current interface
        $grefhCurrent->{If}->{"$Desc"}->{ifOperStatus} = "$OperStatusNow";
        $grefhCurrent->{MD}->{IfIndexTable}->{"OperStatus"}->{"$Index"} = "$OperStatusNow";

        #
        # Store a CacheTimer (seconds) where we cache the next
        # reads from the net - we have the following possibilities
        #
        # ifOperStatus:
        #
        # Current state | first state  |  CacheTimer
        # -----------------------------------------
        # up              up              $gShortCacheTimer
        # up              down            0
        # down            down            $gLongCacheTimer
        # down            up              0
        # other           *               0
        # *               other           0
        #
        # One exception to that logic is the "Changed" flag. If this
        # is set we detected a change on an interface property and do not
        # cache !
        #
        my $OperStatusFile = $grefhFile->{If}->{"$Desc"}->{ifOperStatus};
        unless ($OperStatusFile) {$OperStatusFile = "";}
        
        logger(1, "Now=\"$OperStatusNow\" File=\"$OperStatusFile\"");
        # set cache timer for further reads
        if ("$OperStatusNow" eq "up" and "$OperStatusFile" eq "up") {
            $grefhCurrent->{MD}->{If}->{"$Desc"}->{CacheTimer} = $gShortCacheTimer;
        } elsif ("$OperStatusNow" eq "down" and "$OperStatusFile" eq "down") {
            $grefhCurrent->{MD}->{If}->{"$Desc"}->{CacheTimer} = $gLongCacheTimer;
        } else {
            $grefhCurrent->{MD}->{If}->{"$Desc"}->{CacheTimer} = 0;
            $grefhCurrent->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeText} =
                "Old = \"$OperStatusFile\", Current = \"$OperStatusNow\" ";
        }

        # remember change time of the interface property
        if ($grefhFile->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeTime}) {
                        # umkopieren damit am Ende die Info erhalten bleibt
                $grefhCurrent->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeTime} =
                    $grefhFile->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeTime}
        } else {
            $grefhCurrent->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeTime} = time;
        }

        # track changes of the oper status
        if ("$OperStatusNow" eq "$OperStatusFile") {   # no changes to its first state
            # delete the changed flag and reset the time when it was changed
            if ($grefhFile->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeText}) {
                delete $grefhCurrent->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeText};
                $grefhCurrent->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeTime} = time;
            }
        }
        # ifOperstatus has changed to up, no alert
        elsif ("$OperStatusNow" ne "down") {
            # update the state in the status file
            $grefhFile->{If}->{"$Desc"}->{ifOperStatus} = "$OperStatusNow";
            # delete the changed flag and reset the time when it was changed
            if ($grefhFile->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeText}) {
                delete $grefhCurrent->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeText};
                $grefhCurrent->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeTime} = time;
            }
        }
        # ifOperstatus has changed, alerting
        else {
            # flag if changes already tracked
            if (not $grefhFile->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeText}) {
                $grefhCurrent->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeTime} = time;
            }

            # remember the change every run of this program, this is useful if the
            # ifOperStatus changes from "up" to "testing" to "down"
            $grefhCurrent->{MD}->{If}->{"$Desc"}->{ifOperStatusChangeText} =
                "Old = \"$OperStatusFile\", Current = \"$OperStatusNow\" ";
        }


        # create another tree in the MetaData hash which stores interface index
        # and description. This is used later wehen getting the ip address
        # and for displaying the html table
        $grefhCurrent->{MD}->{IfIndexTable}->{ByIndex}->{"$Index"} = "$Desc";
        $grefhCurrent->{MD}->{IfIndexTable}->{ByName}->{"$Desc"} = "$Index";

         # Store Index und Description in MD. This is needed for displaying the
         # Html table. lukas2
         $grefhCurrent->{If}->{$Desc}->{index}   = "$Index";
         $grefhCurrent->{If}->{$Desc}->{ifDescr} = "$Desc";

    }
    return 0;
}

# ------------------------------------------------------------------------
# get trafic in octets (ifInOctets / ifOutOctets)
# ------------------------------------------------------------------------
sub Get_TraficInOut {

    my $refaOctetLines = shift;
    my $WhatOctet = shift;
    my $WhatBit = shift;

    # Example of $refaOctetLines
    #    .1.3.6.1.2.1.2.2.1.10.2 2510821601
    #    .1.3.6.1.2.1.2.2.1.10.3 0
    for (@$refaOctetLines) {
        my ($Index,$Octets) = split / /,$_,2;
        $Index =~ s/^.*\.//g;    # remove all but the index
        $Octets =~ s/\s+$//g;    # remove invisible chars from the end
        my $Bits = $Octets * 8;  # convert in bits

        # Store the octets of the current interface
        $grefhCurrent->{MD}->{IfIndexTable}->{"$WhatOctet"}->{"$Index"} = "$Octets";
        $grefhFile->{'history'}->{$STARTTIME}->{"$WhatOctet"}->{"$Index"} = "$Octets";
        # Store the bits of the current interface
        $grefhCurrent->{MD}->{IfIndexTable}->{"$WhatBit"}->{"$Index"} = "$Bits";
    }
    return 0;
}

# ------------------------------------------------------------------------
# get trafic in bits (ifInOctets / ifOutOctets)
# ------------------------------------------------------------------------
sub Get_IfErrInOut {

    my $refaIfErrLines = shift;
    my $What = shift;

    # Example of $refaIfErrLines
    #    .1.3.6.1.2.1.2.2.1.14.1 201
    #    .1.3.6.1.2.1.2.2.1.14.2 0
    for (@$refaIfErrLines) {
        my ($Index,$IfErr) = split / /,$_,2;
        $Index =~ s/^.*\.//g;    # remove all but the index
        $IfErr =~ s/\s+$//g;    # remove invisible chars from the end

        # Store the Errors of the current interface
        $grefhCurrent->{MD}->{IfIndexTable}->{"$What"}->{"$Index"} = "$IfErr";
        $grefhFile->{'history'}->{$STARTTIME}->{"$What"}->{"$Index"} = "$IfErr";
    }
    return 0;
}

# ------------------------------------------------------------------------
# get packet discards (ifInDiscards/ifOutDiscards)
# ------------------------------------------------------------------------
sub Get_IfDiscardInOut {

    my $refaIfDiscardLines = shift;
    my $What = shift;

    # Example of $refaIfDiscardLines
    #    .1.3.6.1.2.1.2.2.1.13.1 201
    #    .1.3.6.1.2.1.2.2.1.13.2 0
    for (@$refaIfDiscardLines) {
        my ($Index,$IfDiscard) = split / /,$_,2;
        $Index =~ s/^.*\.//g;    # remove all but the index
        $IfDiscard =~ s/\s+$//g;    # remove invisible chars from the end

        # Store the Discards of the current interface
        $grefhCurrent->{MD}->{IfIndexTable}->{"$What"}->{"$Index"} = "$IfDiscard";
        $grefhFile->{'history'}->{$STARTTIME}->{"$What"}->{"$Index"} = "$IfDiscard";
    }
    return 0;
}

# ------------------------------------------------------------------------
# clean outdated historical data statistics and select the one eligible
# for bandwitdh calculation
# ------------------------------------------------------------------------
sub CleanAndSelectHistoricalDataset {

    #logger(3, "perfdata dirty:\n".Dumper($grefhFile));

    my $firsttime = $STARTTIME;

    # loop through all historical perfdata
    for my $time (sort keys %{$grefhFile->{'history'}}) {
        if (($STARTTIME - ($ghOptions{'delta'} + 200)) > $time) {
            # delete anything older than starttime - (delta + a bit buffer)
            # so we keep a sliding window following us
            delete $grefhFile->{'history'}->{$time};
            logger(1, "outdated perfdata cleanup: $time");
        } elsif ($time < $firsttime) {
            # chose the oldest dataset to compare with
            $firsttime = $time;
            $gUsedDelta = $STARTTIME - $firsttime;
            logger(1, "now ($STARTTIME) - comparetimestamp ($time) = used delta ($gUsedDelta)");
            last;
        } else {
            # no dataset (left) to compare with
            # no further calculations if we run for the first time.
            $firsttime = undef;
            logger(1, "no dataset (left) to compare with, bandwitdh calculations will not be done");
        }
    }
    return $firsttime;
}

# ------------------------------------------------------------------------
# calculate rate / bandwidth usage within a specified period
# ------------------------------------------------------------------------
sub CalculateBps {
    my $firsttime = shift;
    # check if the counter is back to 0 after 2^32 / 2^64.
    # First set the modulus depending on highperf counters or not
    #my $overfl_mod = defined ($o_highperf) ? 18446744073709551616 : 4294967296;
    my $overfl_mod = 4294967296;
    
    # $grefaAllIndizes is a indexed and sorteted list of all interfaces
    for my $Index (@$grefaAllIndizes) {

        # ---------- Bandwidth calculation -----------
        
        my $overfl      = 0;
        my $bpsIn       = 0;
        my $bpsOut      = 0;
        
        # be sure that history exist
        # then check if the counter is back to 0 after 2^32 / 2^64.
        if (defined $grefhFile->{'history'}->{$STARTTIME}->{OctetsIn}->{"$Index"} 
            and defined $grefhFile->{'history'}->{$firsttime}->{OctetsIn}->{"$Index"}){ 
                $overfl = ($grefhFile->{'history'}->{$STARTTIME}->{OctetsIn}->{"$Index"} >=
                    $grefhFile->{'history'}->{$firsttime}->{OctetsIn}->{"$Index"} ) ? 0 : $overfl_mod;
                $bpsIn = ($grefhFile->{'history'}->{$STARTTIME}->{OctetsIn}->{"$Index"} -
                    $grefhFile->{'history'}->{$firsttime}->{OctetsIn}->{"$Index"} + $overfl) / $gUsedDelta * 8;
        }
        
        # be sure that history exist
        # then check if the counter is back to 0 after 2^32 / 2^64.
        if (defined $grefhFile->{'history'}->{$STARTTIME}->{OctetsOut}->{"$Index"} 
            and defined $grefhFile->{'history'}->{$firsttime}->{OctetsOut}->{"$Index"}){ 
                $overfl = ($grefhFile->{'history'}->{$STARTTIME}->{OctetsOut}->{"$Index"} >=
                    $grefhFile->{'history'}->{$firsttime}->{OctetsOut}->{"$Index"} ) ? 0 : $overfl_mod;
                $bpsOut = ($grefhFile->{'history'}->{$STARTTIME}->{OctetsOut}->{"$Index"} -
                    $grefhFile->{'history'}->{$firsttime}->{OctetsOut}->{"$Index"} + $overfl) / $gUsedDelta * 8;
        }
        
        my $oid_ifDescr = $grefhCurrent->{MD}->{IfIndexTable}->{ByIndex}->{$Index};

        # bandwidth usage in percent of (configured/negotiated) interface speed
        if ($grefhCurrent->{If}->{$oid_ifDescr}->{ifSpeed} > 0) {
            my $ifLoadIn  = 100 * $bpsIn  / $grefhCurrent->{If}->{$oid_ifDescr}->{ifSpeed};
            my $ifLoadOut = 100 * $bpsOut / $grefhCurrent->{If}->{$oid_ifDescr}->{ifSpeed};
            $grefhCurrent->{If}->{$oid_ifDescr}->{ifLoadIn}  = sprintf("%.2f", $ifLoadIn);
            $grefhCurrent->{If}->{$oid_ifDescr}->{ifLoadOut} = sprintf("%.2f", $ifLoadOut);
            # check interface utilization in percent

            if ($ifLoadIn > 0 or $ifLoadOut > 0) {
                # just traffic light color codes for the lame
                if ($ifLoadIn > $ghOptions{'critical-load'} or $ifLoadOut > $ghOptions{'critical-load'}) {
                    push @{$grefhListOfChanges->{loadcritical}}, trim(denormalize($oid_ifDescr));
                    $gIfLoadCritCounter++;
                } elsif ($ifLoadIn > $ghOptions{'warning-load'} or $ifLoadOut > $ghOptions{'warning-load'}) {
                    push @{$grefhListOfChanges->{loadwarning}}, trim(denormalize($oid_ifDescr));
                    $gIfLoadWarnCounter++;
                } 
                $grefhCurrent->{If}->{$oid_ifDescr}->{ifLoadInOutOfRange} = colorcode($ifLoadIn, $ghOptions{'warning-load'}, $ghOptions{'critical-load'});
                $grefhCurrent->{If}->{$oid_ifDescr}->{ifLoadOutOutOfRange} = colorcode($ifLoadOut, $ghOptions{'warning-load'}, $ghOptions{'critical-load'});
            }
        } else {
            $grefhCurrent->{If}->{$oid_ifDescr}->{ifLoadIn} = 0;
            $grefhCurrent->{If}->{$oid_ifDescr}->{ifLoadOut} = 0;
        }

        #print OUT "BandwidthUsageIn=${bpsIn}bps;0;0;0;$grefhCurrent->{If}->{$oid_ifDescr}->{ifSpeed} ";
        #print OUT "BandwidthUsageOut=${bpsOut}bps;0;0;0;$grefhCurrent->{If}->{$oid_ifDescr}->{ifSpeed} ";

        my $SpeedUnitOut='';
        my $SpeedUnitIn='';
        if ($ghOptions{human}) {
            # human readable bandwidth usage in (G/M/K)bits per second
            $SpeedUnitIn=' bps';
            if ($bpsIn > 1000000000) {        # in Gbit/s = 1000000000 bit/s
                  $bpsIn = $bpsIn / 1000000000;
                  $SpeedUnitIn=' Gbps';
            } elsif ($bpsIn > 1000000) {      # in Mbit/s = 1000000 bit/s
                  $bpsIn = $bpsIn / 1000000;
                  $SpeedUnitIn=' Mbps';
            } elsif ($bpsIn > 1000) {         # in Kbits = 1000 bit/s
                  $bpsIn = $bpsIn / 1000;
                  $SpeedUnitIn=' Kbps';
            }

            $SpeedUnitOut=' bps';
            if ($bpsOut > 1000000000) {       # in Gbit/s = 1000000000 bit/s
                  $bpsOut = $bpsOut / 1000000000;
                  $SpeedUnitOut=' Gbps';
            } elsif ($bpsOut > 1000000) {     # in Mbit/s = 1000000 bit/s
                  $bpsOut = $bpsOut / 1000000;
                  $SpeedUnitOut=' Mbps';
            } elsif ($bpsOut > 1000) {        # in Kbit/s = 1000 bit/s
                  $bpsOut = $bpsOut / 1000;
                  $SpeedUnitOut=' Kbps';
            }
        }

        $grefhCurrent->{If}->{$oid_ifDescr}->{bpsIn} = sprintf("%.2f$SpeedUnitIn", $bpsIn);
        $grefhCurrent->{If}->{$oid_ifDescr}->{bpsOut} = sprintf("%.2f$SpeedUnitOut", $bpsOut);

        # ---------- Last traffic calculation -----------
        
        # remember last traffic time
        if ($bpsIn > 0 or $bpsOut > 0) { # there is traffic now, remember it
            $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{LastTraffic} = $STARTTIME;
            #logger(1, "setze neuen wert!!! LastTraffic: ", $STARTTIME);
        } elsif (not defined $grefhFile->{MD}->{If}->{$oid_ifDescr}->{LastTraffic}) {
            #if ($gInitialRun) {
            #    # initialize on the first run
            #    $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{LastTraffic} = $STARTTIME;
            #} else {
                $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{LastTraffic} = 0;
            #}
            #logger(1, "grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{LastTraffic}: not defined");
        } else { # no traffic now, dont forget the old value
            $grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{LastTraffic} = $grefhFile->{MD}->{If}->{$oid_ifDescr}->{LastTraffic};
            #$grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{LastTraffic} = $STARTTIME;
            #logger(1, "merke alten wert!!! LastTraffic: ", $grefhFile->{MD}->{If}->{$oid_ifDescr}->{LastTraffic});
        }
        # Set LastTrafficInfo to this Format "0d 0h 43m" and compare the critical and warning levels for "unused interface"
        ($grefhCurrent->{If}->{$oid_ifDescr}->{ifLastTraffic}, my $LastTrafficStatus) =
            TimeDiff ($grefhCurrent->{MD}->{If}->{$oid_ifDescr}->{LastTraffic}, $STARTTIME,
                $ghOptions{lasttrafficwarn}, $ghOptions{lasttrafficcrit});
        
        # ---------- Last traffic calculation -----------
        
        # ifUsage variable:
        #   * -1  -> interface used, unknown last traffic
        #   * 0   -> interface used, last traffic is < crit duration
        #   * 1   -> interface unused, last traffic is >= crit duration
        
        if ($LastTrafficStatus == $ERRORS{'CRITICAL'}) {
            logger(2, "  (debug) interface unused, last traffic is >= crit duration");
            # this means "no traffic seen during the last LastTrafficCrit seconds"
            $grefhCurrent->{If}->{$oid_ifDescr}->{ifLastTrafficOutOfRange} = "red";
            $grefhCurrent->{If}->{$oid_ifDescr}->{ifUsage} = 1; # interface unused
        } elsif ($LastTrafficStatus == $ERRORS{'WARNING'}) {
            logger(2, "  (debug) interface used, last traffic is < crit duration");
            # this means "no traffic seen during the last LastTrafficWarn seconds"
            $grefhCurrent->{If}->{$oid_ifDescr}->{ifLastTrafficOutOfRange} = "yellow";
            $grefhCurrent->{If}->{$oid_ifDescr}->{ifUsage} = 0; # interface used
        } elsif ($LastTrafficStatus == $ERRORS{'UNKNOWN'}) {
            logger(2, "  (debug) interface used, unknown last traffic");
            # this means "no traffic seen during the last LastTrafficWarn seconds"
            $grefhCurrent->{If}->{$oid_ifDescr}->{ifLastTrafficOutOfRange} = "orange";
            $grefhCurrent->{If}->{$oid_ifDescr}->{ifUsage} = -1; # interface unused
        } else {
            logger(2, "  (debug) interface used, last traffic is < crit duration");            
            logger(1, "  (debug) LastTraffic ($oid_ifDescr): ", $grefhFile->{MD}->{If}->{$oid_ifDescr}->{LastTraffic});
            # this means "there is traffic on the interface during the last LastTrafficWarn seconds"
            $grefhCurrent->{If}->{$oid_ifDescr}->{ifUsage} = 0; # interface used
        }
        check_for_unused_interfaces ($oid_ifDescr, $grefhCurrent->{If}->{$oid_ifDescr}->{ifUsage});

    }
    #logger(3, "grefhCurrent: " . Dumper ($grefhCurrent));
    #logger(3, "grefhFile: " . Dumper ($grefhFile));
    #logger(3, "grefhCurrent: " . Dumper ($grefhCurrent->{If}));
    #logger(3, "grefhFile: " . Dumper ($grefhFile->{If}));

    return 0;
}

# ------------------------------------------------------------------------
# evaluate packets within a specified period
# ------------------------------------------------------------------------
sub EvaluatePackets {
    my $firsttime = shift;
    # check if the counter is back to 0 after 2^32 / 2^64.
    # First set the modulus depending on highperf counters or not
    #my $overfl_mod = defined ($o_highperf) ? 18446744073709551616 : 4294967296;
    my $overfl_mod = 4294967296;
    
    # $grefaAllIndizes is a indexed and sorteted list of all interfaces
    for my $Index (@$grefaAllIndizes) {

        my $overfl              = 0;
        my $ppsErrIn            = 0;
        my $ppsErrOut           = 0;
        my $ppsDiscardIn        = 0;
        my $ppsDiscardOut       = 0;
        
        # be sure that history exist
        # then check if the counter is back to 0 after 2^32 / 2^64.
        if (defined $grefhFile->{'history'}->{$STARTTIME}->{PktsInErr}->{"$Index"} 
            and defined $grefhFile->{'history'}->{$firsttime}->{PktsInErr}->{"$Index"}){ 
                $overfl = ($grefhFile->{'history'}->{$STARTTIME}->{PktsInErr}->{"$Index"} >=
                    $grefhFile->{'history'}->{$firsttime}->{PktsInErr}->{"$Index"} ) ? 0 : $overfl_mod;
                $ppsErrIn = ($grefhFile->{'history'}->{$STARTTIME}->{PktsInErr}->{"$Index"} -
                    $grefhFile->{'history'}->{$firsttime}->{PktsInErr}->{"$Index"} + $overfl) / $gUsedDelta * 8;
        }
        if (defined $grefhFile->{'history'}->{$STARTTIME}->{PktsOutErr}->{"$Index"} 
            and defined $grefhFile->{'history'}->{$firsttime}->{PktsOutErr}->{"$Index"}){ 
                $overfl = ($grefhFile->{'history'}->{$STARTTIME}->{PktsOutErr}->{"$Index"} >=
                    $grefhFile->{'history'}->{$firsttime}->{PktsOutErr}->{"$Index"} ) ? 0 : $overfl_mod;
                $ppsErrOut = ($grefhFile->{'history'}->{$STARTTIME}->{PktsOutErr}->{"$Index"} -
                    $grefhFile->{'history'}->{$firsttime}->{PktsOutErr}->{"$Index"} + $overfl) / $gUsedDelta * 8;
        }
        if (defined $grefhFile->{'history'}->{$STARTTIME}->{PktsInDiscard}->{"$Index"} 
            and defined $grefhFile->{'history'}->{$firsttime}->{PktsInDiscard}->{"$Index"}){ 
                $overfl = ($grefhFile->{'history'}->{$STARTTIME}->{PktsInDiscard}->{"$Index"} >=
                    $grefhFile->{'history'}->{$firsttime}->{PktsInDiscard}->{"$Index"} ) ? 0 : $overfl_mod;
                $ppsDiscardIn = ($grefhFile->{'history'}->{$STARTTIME}->{PktsInDiscard}->{"$Index"} -
                    $grefhFile->{'history'}->{$firsttime}->{PktsInDiscard}->{"$Index"} + $overfl) / $gUsedDelta * 8;
        }
        if (defined $grefhFile->{'history'}->{$STARTTIME}->{PktsOutDiscard}->{"$Index"} 
            and defined $grefhFile->{'history'}->{$firsttime}->{PktsOutDiscard}->{"$Index"}){ 
                $overfl = ($grefhFile->{'history'}->{$STARTTIME}->{PktsOutDiscard}->{"$Index"} >=
                    $grefhFile->{'history'}->{$firsttime}->{PktsOutDiscard}->{"$Index"} ) ? 0 : $overfl_mod;
                $ppsDiscardOut = ($grefhFile->{'history'}->{$STARTTIME}->{PktsOutDiscard}->{"$Index"} -
                    $grefhFile->{'history'}->{$firsttime}->{PktsOutDiscard}->{"$Index"} + $overfl) / $gUsedDelta * 8;
        }
        
        my $oid_ifDescr = $grefhCurrent->{MD}->{IfIndexTable}->{ByIndex}->{$Index};

        # compare against thresholds
        my $pwarn = 0; 
        my $pcrit = 0;
        $grefhCurrent->{If}->{$oid_ifDescr}->{ppsErrIn}  = sprintf("%.2f", $ppsErrIn);
        $grefhCurrent->{If}->{$oid_ifDescr}->{ppsErrOut} = sprintf("%.2f", $ppsErrOut);
        if ($ppsErrIn > 0 or $ppsErrOut > 0) {
            # just traffic light color codes for the lame
            if ($ppsErrIn > $ghOptions{'critical-pkterr'} or $ppsErrOut > $ghOptions{'critical-pkterr'}) {
                push @{$grefhListOfChanges->{'critical-pkterr'}}, trim(denormalize($oid_ifDescr));
                $gPktErrCritCounter++;
                $pcrit++;
            } elsif ($ppsErrIn > $ghOptions{'warning-pkterr'} or $ppsErrOut > $ghOptions{'warning-pkterr'}) {
                push @{$grefhListOfChanges->{'warning-pkterr'}}, trim(denormalize($oid_ifDescr));
                $gPktErrWarnCounter++;
                $pwarn++;
            } 
            $grefhCurrent->{If}->{$oid_ifDescr}->{ppsErrInOutOfRange} = colorcode($ppsErrIn, $ghOptions{'warning-pkterr'}, $ghOptions{'critical-pkterr'});
            $grefhCurrent->{If}->{$oid_ifDescr}->{ppsErrOutOutOfRange} = colorcode($ppsErrOut, $ghOptions{'warning-pkterr'}, $ghOptions{'critical-pkterr'});
        }
        $grefhCurrent->{If}->{$oid_ifDescr}->{ppsDiscardIn}  = sprintf("%.2f", $ppsDiscardIn);
        $grefhCurrent->{If}->{$oid_ifDescr}->{ppsDiscardOut} = sprintf("%.2f", $ppsDiscardOut);
        if ($ppsDiscardIn > 0 or $ppsDiscardOut > 0) {
            # just traffic light color codes for the lame
            if ($ppsDiscardIn > $ghOptions{'critical-pktdiscard'} or $ppsDiscardOut > $ghOptions{'critical-pktdiscard'}) {
                push @{$grefhListOfChanges->{'critical-pktdiscard'}}, trim(denormalize($oid_ifDescr));
                $gPktDiscardCritCounter++;
                $pcrit++;
            } elsif ($ppsDiscardIn > $ghOptions{'warning-pktdiscard'} or $ppsDiscardOut > $ghOptions{'warning-pktdiscard'}) {
                push @{$grefhListOfChanges->{'warning-pktdiscard'}}, trim(denormalize($oid_ifDescr));
                $gPktDiscardWarnCounter++;
                $pwarn++;
            } 
            $grefhCurrent->{If}->{$oid_ifDescr}->{ppsDiscardInOutOfRange} = colorcode($ppsDiscardIn, $ghOptions{'warning-pktdiscard'}, $ghOptions{'critical-pktdiscard'});
            $grefhCurrent->{If}->{$oid_ifDescr}->{ppsDiscardOutOutOfRange} = colorcode($ppsDiscardOut, $ghOptions{'warning-pktdiscard'}, $ghOptions{'critical-pktdiscard'});
        }
        # totals field
        $grefhCurrent->{If}->{$oid_ifDescr}->{pktErrDiscard} = sprintf("%.0f/%.0f/%.0f/%.0f", $ppsErrIn, $ppsErrOut, $ppsDiscardIn, $ppsDiscardOut);
        if ($pcrit > 0) {
            $grefhCurrent->{If}->{$oid_ifDescr}->{pktErrDiscardOutOfRange} = 'red';
        } elsif ($pwarn > 0) {
            $grefhCurrent->{If}->{$oid_ifDescr}->{pktErrDiscardOutOfRange} = 'yellow';
        }
    }   
    
    return 0;
}

# ------------------------------------------------------------------------
# extract ip addresses out of snmpwalk lines
#
# # snmpwalk -Oqn -c public -v 1 router IP-MIB::ipAdEntIfIndex
# .1.3.6.1.2.1.4.20.1.2.172.31.92.91 15
# .1.3.6.1.2.1.4.20.1.2.172.31.92.97 15
# .1.3.6.1.2.1.4.20.1.2.172.31.99.76 15
# .1.3.6.1.2.1.4.20.1.2.193.83.153.254 29
# .1.3.6.1.2.1.4.20.1.2.193.154.197.192 14
#
# ------------------------------------------------------------------------
sub Get_IpAddress_SubnetMask {
    my $refaIPLines = shift;

    my $refaNetMask;

    # store all ip information in the hash to avoid reading the netmask
    # again in the next run
    $grefhCurrent->{MD}->{SnmpIpInfo} = join (";",@$refaIPLines);

    # remove all invisible chars incl. \r and \n
    $grefhCurrent->{MD}->{SnmpIpInfo} =~ s/[\000-\037]|[\177-\377]//g;
	
    # # snmpwalk -Oqn -v 1 -c public router IP-MIB::ipAdEntNetMask
    # .1.3.6.1.2.1.4.20.1.3.172.31.92.91 255.255.255.255
    # .1.3.6.1.2.1.4.20.1.3.172.31.92.97 255.255.255.255
    #
    # read the subnet masks with caching 0 only if the ip addresses
    # have changed
    if (defined $grefhFile->{MD}->{SnmpIpInfo} and $grefhCurrent->{MD}->{SnmpIpInfo} eq $grefhFile->{MD}->{SnmpIpInfo}) {
        $refaNetMask = GetDataWithUnixSnmpWalk ($ghOptions{'hostquery'},$ghOptions{'community'},$oid_ipAdEntNetMask,$ghOptions{'cachedir'},$gLongCacheTimer);
    } else {
        $refaNetMask = GetDataWithUnixSnmpWalk ($ghOptions{'hostquery'},$ghOptions{'community'},$oid_ipAdEntNetMask,$ghOptions{'cachedir'},0);
    }

    # Example lines:
    # .1.3.6.1.2.1.4.20.1.2.172.31.99.76 15
    # .1.3.6.1.2.1.4.20.1.2.193.83.153.254 29
    logger(3, "IP information lines (refaIPLines): ".Dumper($refaIPLines));
    for (@$refaIPLines) {
        my ($IpAddress,$Index) = split / /,$_,2;        # blank splits OID & ifIndex
        $IpAddress  =~  s/^.*1\.4\.20\.1\.2\.//;    # remove up to the ip address
        $Index          =~  s/\D//g;                    # remove all but numbers
                
        # extract the netmask
        #
        # $refaNetMaks looks like this:
        #
        # $VAR1 = [
        #          '.1.3.6.1.2.1.4.20.1.3.10.1.1.4 255.255.0.0',
        #          '.1.3.6.1.2.1.4.20.1.3.10.2.1.4 255.255.0.0',
        #          '.1.3.6.1.2.1.4.20.1.3.172.30.1.4 255.255.0.0
        #        ];

        my ($Tmp,$NetMask) = split (" ",join ("",grep /$IpAddress /,@$refaNetMask),2);
        $NetMask    =~ s/\s+$//;    # remove invisible chars from the end

        logger(3, "Index: $Index, IpAddress: $IpAddress, Netmask: $NetMask");
        
        # get the interface description stored before from the index table
        my $Desc = $grefhCurrent->{MD}->{IfIndexTable}->{ByIndex}->{"$Index"};
        
        #Check that a mapping was possible between the ip info and an interface
        if ($Desc) {
        
            # separate multiple IP Adresses with a blank
            # blank is good because the WEB browser can break lines
            if ($grefhCurrent->{If}->{"$Desc"}->{IpInfo}) {
                $grefhCurrent->{If}->{"$Desc"}->{IpInfo} =
                $grefhCurrent->{If}->{"$Desc"}->{IpInfo}." "
            }
            # now we are finished with the puzzle of getting ip and subnet mask
            # add IpInfo as property to the interface
            my $IpInfo = "$IpAddress/$NetMask";
            $grefhCurrent->{If}->{"$Desc"}->{IpInfo} .= $IpInfo;
    
            # check if the IP address has changed to its first run
            my $FirstIpInfo = $grefhFile->{If}->{"$Desc"}->{IpInfo};
            unless ($FirstIpInfo) {$FirstIpInfo = "";}
            
            # disable caching of this interface if ip information has changed
            if ("$IpInfo" ne "$FirstIpInfo") {
                $grefhCurrent->{MD}->{If}->{"$Desc"}->{CacheTimer} = 0;
                $grefhCurrent->{MD}->{If}->{"$Desc"}->{CacheTimerComment} =
                    "caching is disabled because of first or current IpInfo";
            }
        } else {
            logger(3, "Impossible to map the IP info to any existing interface: no corresponding interface index. Skipping IP info.");
        }
    }
    return 0;
}

# ------------------------------------------------------------------------
# Read config file with the perl Config::General Module
#
#   http://search.cpan.org/search?query=Config%3A%3AGeneral&mode=all
#
# ------------------------------------------------------------------------
sub ReadConfigFileNew {

    my $ConfigFile = shift;

    my $refoConfig; # object definition for the config
    my $refhConfig; # hash reference returned

    # return undef if file is not readable
    -r "$ConfigFile" or return $refhConfig;

    # Initialize ConfigFile Read Process (create object)
    eval {
        $refoConfig = new Config::General (
            -ConfigFile             => "$ConfigFile",
            -UseApacheInclude       => "false",
            -MergeDuplicateBlocks   => "false",
            -InterPolateVars        => "false",
        );
    };
    if($@) {
        # it's not successfull so remove the bad config file and try again.
        logger(1, "CONFIG READ FAIL: create new one ($ConfigFile).");
        unlink "$ConfigFile";
        return $refhConfig;
    }

    # Read Config File
    %$refhConfig = $refoConfig->getall;

    # return reference
    return $refhConfig;
}
# ------------------------------------------------------------------------
# --- write a hash reference to a file --- see ReadConfigFileNew ---------
#
# $gFile = full qulified filename with path
# $refhStruct = hash reference
#
# ------------------------------------------------------------------------
sub WriteConfigFileNew {
    my $ConfigFile   =   shift;
    my $refhStruct   =   shift;

    use File::Basename;

    my $refoConfig; # object definition for the config
    my $Directory = dirname ($ConfigFile);

    # Initialize ConfigFile Read Process (create object)
    $refoConfig = new Config::General (
        -ConfigPath => "$Directory"
    );

    # Write Config File
    if (-f "$ConfigFile" and not -w "$ConfigFile") {
        print "Unable to write to file $ConfigFile $!\n";
        exit $ERRORS{"UNKNOWN"};
    }

    umask "$UMASK";
    $refoConfig->save_file("$ConfigFile", $refhStruct);
    logger(1, "Wrote interface data to file: $ConfigFile");

    return 0;
}
# ------------------------------------------------------------------------
# walk through each interface and read ifAdminStatus, ifSpeed and ifAlias
# ------------------------------------------------------------------------
sub Get_AdminStatus_Speed_Alias_Vlan {

    # loop through all found interfaces
    for my $Desc (keys %{$grefhCurrent->{If}}) {

        my $CacheTimer = 0;

        # extract the index out of the MetaData
        my $Index           = $grefhCurrent->{MD}->{IfIndexTable}->{ByName}->{"$Desc"};

        # Current state | first state  |  CacheTimer
        # -----------------------------------------
        # down            down            $gLongCacheTimer
        # *               *               0
        my $OperStatusNow  = $grefhCurrent->{If}->{"$Desc"}->{ifOperStatus};
        my $OperStatusFile = $grefhFile->{If}->{"$Desc"}->{ifOperStatus};
        unless ($OperStatusFile) {$OperStatusFile = "";}
        
         # Set cachtimer to the long cache timer value if the operstatus is now down
         # and was down in the past.
         if ( ( "$OperStatusNow" eq "down" ) and ( "$OperStatusFile" eq "down" ) ) {
            $CacheTimer = $gLongCacheTimer;
         }

        # get next interface properties with caching to avoid network load
        my $refhSNMP = GetMultipleDataWithSnmp (
            $ghOptions{'hostquery'},$ghOptions{'community'},[ "$oid_ifAdminStatus.$Index", "$oid_ifSpeed.$Index","$oid_ifAlias.$Index" ],$ghOptions{'cachedir'},$CacheTimer);

        # store ifAdminStatus converted from a digit to "up" or "down"
        $grefhCurrent->{If}->{"$Desc"}->{ifAdminStatus} =
            ConvertIfStatusToReadable ($refhSNMP->{"$oid_ifAdminStatus.$Index"});

        # store ifSpeed in a machine and human readable format
        $grefhCurrent->{If}->{"$Desc"}->{ifSpeed} =
            ($refhSNMP->{"$oid_ifSpeed.$Index"});
        $grefhCurrent->{If}->{"$Desc"}->{ifSpeedReadable} =
            ConvertSpeedToReadable ($refhSNMP->{"$oid_ifSpeed.$Index"});

        # store ifAlias normalized to not get into trouble with special chars
        $grefhCurrent->{If}->{"$Desc"}->{ifAlias} =
            normalize ($refhSNMP->{"$oid_ifAlias.$Index"});

        if ($ghOptions{vlan}) { # show VLANs per port
                # clear ifVlanNames
                $grefhCurrent->{If}->{"$Desc"}->{ifVlanNames} = '';
                }
    }

    if ($ghOptions{vlan}) { # show VLANs per port

        my $VlanNames = GetDataWithUnixSnmpWalk ($ghOptions{'hostquery'},$ghOptions{'community'},$oid_ifVlanName,$ghOptions{'cachedir'},0);
        my $VlanPortHP = GetDataWithUnixSnmpWalk ($ghOptions{'hostquery'},$ghOptions{'community'},$oid_ifVlanPortHP,$ghOptions{'cachedir'},0);
        my $VlanPortCisco = GetDataWithUnixSnmpWalk ($ghOptions{'hostquery'},$ghOptions{'community'},$oid_ifVlanPortCisco,$ghOptions{'cachedir'},0);

        # store Vlan names in a hash
        my %vlanname;
        foreach my $tmp ( @$VlanNames ) {
            my ($oid, @name) = split(/ /, $tmp);
                chomp(@name);
                $vlanname{$oid} = "@name";
                $vlanname{$oid} =~ tr/"<>/'../; #"
        }
        if (@$VlanPortHP > 0) {
            foreach my $tmp ( @$VlanPortHP ) {
                my ($oid, $port) = split(/ /, $tmp);
                        chomp($port);
                my @oid = split(/\./, $oid);
                        my $vlan = $oid[-2];
                my $oid_ifDescr = $grefhCurrent->{MD}->{IfIndexTable}->{ByIndex}->{$port};

                # store ifVlanNames
                $grefhCurrent->{If}->{"$oid_ifDescr"}->{ifVlanNames} .= $vlanname{"$oid_ifVlanName.$vlan"}. " ";

                #logger(1, " (Debug) VlanName -> $port, " . $vlanname{"$oid_ifVlanName.$vlan"});
                }
        }
        if (@$VlanPortCisco > 0) {
            foreach my $tmp ( @$VlanPortCisco ) {
                my ($oid, $vlan) = split(/ /, $tmp);
                        chomp($vlan);
                my @oid = split(/\./, $oid);
                        my $port = $oid[-1];
                my $oid_ifDescr = $grefhCurrent->{MD}->{IfIndexTable}->{ByIndex}->{$port};

                # store ifVlanNames
                $grefhCurrent->{If}->{"$oid_ifDescr"}->{ifVlanNames} .= $vlan. " ";

                #logger(1, " (Debug) VlanName -> $port, " . $vlan ."");
                }
        }
        }

    return 0;
}
# ------------------------------------------------------------------------
# extract two cache timers out of the commandline -cache option
#
# Examples:
#   -cache 150              $gShortCacheTimer = 150 and $Long... = 300
#   -cache 3600,86400       $gShortCacheTimer = 3600 and $Long...= 86400
#
# ------------------------------------------------------------------------
sub ExtractCacheTimer {
    my $CacheString = shift;

    # only one number entered
    if ($CacheString =~ /^\d+$/) {
        $gShortCacheTimer = $CacheString;
        $gLongCacheTimer  = 2*$gShortCacheTimer;
    # two numbers entered - separated with a comma
    } elsif ($CacheString =~ /^\d+$ghOptions{'ifs'}\d+$/) {
        ($gShortCacheTimer,$gLongCacheTimer) = split (/$ghOptions{'ifs'}/,$CacheString);
    } else {
        print "$0: Wrong cache timer specified\n";
        exit $ERRORS{"UNKNOWN"};
    }
    logger(1, "Set ShortCacheTimer = $gShortCacheTimer and LongCacheTimer = $gLongCacheTimer");
    return ($gShortCacheTimer,$gLongCacheTimer);
}
# ------------------------------------------------------------------------
# get the interface speed as integer and convert it to a readable format
# return a string
# ------------------------------------------------------------------------
sub ConvertSpeedToReadable {
    my $Speed = shift;
    if ($Speed > 999999999) {
        $Speed = sprintf ("%0.2f Gbit",$Speed/1000000000);
    } elsif ($Speed > 999999) {
        $Speed = sprintf ("%0.2f Mbit",$Speed/1000000);
    } elsif ($Speed > 999) {
        $Speed = sprintf ("%0.2f kbit",$Speed/1000);
    } elsif ($Speed > 0) {
        $Speed = sprintf ("%0.2f bit",$Speed);
    } else {
        $Speed = "";
    }
    return $Speed;
}
# ------------------------------------------------------------------------
# get the interface administrative/operational status as integer or string and convert
# it to a readable format - return a string
#
# http://www.faqs.org/rfcs/rfc2863.html
#
#    ifAdminStatus OBJECT-TYPE
#        SYNTAX  INTEGER {
#                    up(1),       -- ready to pass packets
#                    down(2),
#                    testing(3),  -- in some test mode
#                    unknown(4),
#                    dormant(5)
#        }
# ------------------------------------------------------------------------
sub ConvertIfStatusToReadable {
    my $status = shift;
    my %status_conversion = ( 1=>'up', 2=>'down', 3=>'testing', 4=>'unknown', 5=>'dormant');
    if ($status =~ /^(1|2|3|4|5)$/) {
        $status = $status_conversion{$status};
    } else {
        # we do nothing and leave the original status
    }
    return $status;
}

# ------------------------------------------------------------------------
# Read all interfaces and its properties into the hash $grefhFile
# ------------------------------------------------------------------------
sub ReadInterfaceInformationFile {

    my $InterfaceInformationFile = shift;

    my $grefhFile;

    # read all properties from the state file - store into $grefhFile
    if (-r "$InterfaceInformationFile") {
        $grefhFile = ReadConfigFileNew ("$InterfaceInformationFile");

        # we got data from an old formated file - check this
        if (not $grefhFile->{MD}->{sysUpTime}) {
            unlink ("$InterfaceInformationFile");   # delete the old file
            print "$0: first run - initializing interface table now\n";
            exit $ERRORS{"OK"};
        }

        # check if the uptime read from the host > then the uptime
        # stored in the file -> means host was not rebooted
        if ($grefhCurrent->{MD}->{sysUpTime} > $grefhFile->{MD}->{sysUpTime} and
            $ghOptions{'cache'}) {

            # extract cache timers out of the command line option
            ($gShortCacheTimer,$gLongCacheTimer) = ExtractCacheTimer ("$ghOptions{'cache'}");
        # it seems that the remote system was rebooted - caching is disabled
        }
    # the file with interface information was not found - this is the first
    # run of the program or it was deleted before
    } else {
        # the file was not found - store the sysUptime immediately
        # Grund: Wenn das Programm mitten drinnen unterbrochen wird
        # (z.B. service check time out) greift beim naechsten Aufruf
        # das Caching.
        WriteConfigFileNew ("$InterfaceInformationFile",$grefhCurrent);
        $gInitialRun = 1;
    }
    return $grefhFile;
}

# ------------------------------------------------------------------------
# calculate time diff of unix epoch seconds and return it in
# a readable format
#
# my $x = TimeDiff ("1150100854","1150234567");
# print $x;   # $x equals to 1d 13h 8m
#
# ------------------------------------------------------------------------
sub TimeDiff {
    my ($StartTime, $EndTime, $warn, $crit) = @_;

    my $Days  = 0;
    my $Hours = 0;
    my $Min   = 0;
    my $Status   = $ERRORS{'UNKNOWN'};
    my $TimeDiff = $EndTime - $StartTime;

    my $Rest;

    my $String = "(NoData)"; # default text (unknown/error)

    # check start not 0
    if ($StartTime == 0) {
        return wantarray ? ('(NoData)', $ERRORS{'UNKNOWN'}) : '(NoData)';
    }

    # check start must be before end
    if ($EndTime < $StartTime) {
        return wantarray ? ('(NoData)', $ERRORS{'UNKNOWN'}) : '(NoData)';
    }

    # check if there is no traffic for $crit or $warn seconds
    if (defined $warn and defined $crit) {
        if ($TimeDiff > $crit) {
            $Status = $ERRORS{'CRITICAL'};
        } elsif ($TimeDiff > $warn) {
            $Status = $ERRORS{'WARNING'};
        } else {
            $Status = $ERRORS{'OK'};
        }
    } else {
        $Status = $ERRORS{'OK'};
    }

    $Days = int ($TimeDiff / 86400);
    $Rest = $TimeDiff - ($Days * 86400);

    if ($Rest < 0) {
        $Days = 0;
        $Hours = int ($TimeDiff / 3600);
    } else {
        $Hours = int ($Rest / 3600);
    }

    $Rest = $Rest - ($Hours * 3600);

    if ($Rest < 0) {
        $Hours = 0;
        $Min = int ($TimeDiff / 60);
    } else {
        $Min = int ($Rest / 60);
    }

    #logger(1, "warn: $warn, crit: $crit, diff: $TimeDiff, status: $Status");
    return wantarray ? ("${Days}d&nbsp;${Hours}h&nbsp;${Min}m", $Status) : "${Days}d&nbsp;${Hours}h&nbsp;${Min}m";
}

# ------------------------------------------------------------------------
# colorcode function to give a html color code between green and red for a given percent value
# ------------------------------------------------------------------------
sub colorcode {
    my $current = shift;
    my $warning = shift;
    my $critical = shift;
    my $colorcode;

    # just traffic light color codes for the lame
    if ($current < $warning) {            # green / ok
        $colorcode = 'green';
    } elsif ($current < $critical) {       # yellow / warn
        $colorcode = 'yellow';
    } else {                          # red / crit
        $colorcode = 'red';
    }

    if ($ghOptions{'ifloadgradient'}) {
        # its cool to have a gradient from green over yellow to red representing the percent value
        # the gradient goes from
        #   #00FF00 (green) at 0 % over
        #   #FFFF00 (yellow) at $warn % to
        #   #FF0000 (red) at $crit % and over

        # first adjust the percent value according to the given warning and critical levels
        if ($current > 0) {
            if ($current <= $warning) {
                $current = $current * 50 / $warning;
            } elsif ($current <= $critical) {
                $current = $current * 100 / $critical;
            }
        }
        my $color = 5.12 * $current;      # (256+256) * $current / 100
        if ($color > 512) { $color = 512 }
        my $red   = ($color > 255) ? 255 : $color;
        my $green = ($color < 255) ? 255 : -1 - (-1 * (512 - $color));
        $colorcode = sprintf "%2.2x%2.2x%2.2x", $red, $green, 0;
        logger(2, " (Debug) colorcode: $colorcode, current: $current, color: $color, red: $red, green: $green");
                # (Debug) colorcode: ff5f00, current: 81.1764679663113, color: 415.623515987514, red: 255, green: 95.3764840124863
                # (Debug) colorcode: b8ff00, current: 36.0897789918691, color: 184.77966843837, red: 184.77966843837, green: 255
    }
    return $colorcode;
}
 
# ------------------------------------------------------------------------
# check_for_unused_interfaces
#  * arg 1: oid ifDescr of the interface
#  * arg 2: free???
#     . -1  -> interface used, unknown last traffic
#     . 0   -> interface used, last traffic is < crit duration
#     . 1   -> interface unused, last traffic is >= crit duration
# ------------------------------------------------------------------------
sub check_for_unused_interfaces {
    my ($oid_ifDescr, $free) = @_;
    
    if ($grefhCurrent->{If}->{"$oid_ifDescr"}->{ifSpeed}) {
        # Interface has a speed property, that can be a physical interface
        
        if ($oid_ifDescr =~ /Ethernet(\d+)Q2F(\d+)Q2F(\d+)/) {
            # we look for ethernet ports (and decide if it is a stacked switch), x/x/x format
            if (not defined $gInterfacesWithoutTrunk->{"$1/$2/$3"}) {
                $gInterfacesWithoutTrunk->{"$1/$2/$3"} = $free;
                $gNumberOfInterfacesWithoutTrunk++;
                # look for free ports with admin status up
                if ($free and $grefhCurrent->{If}->{"$oid_ifDescr"}->{ifAdminStatus} eq 'up') {
                    $grefhCurrent->{If}->{$oid_ifDescr}->{ifLastTrafficOutOfRange} = "yellow";
                    $gNumberOfFreeUpInterfaces++;
                }
            }
        } elsif ($oid_ifDescr =~ /Ethernet(\d+)Q2F(\d+)/) {
            # we look for ethernet ports (and decide if it is a stacked switch), x/x format
            if (not defined $gInterfacesWithoutTrunk->{"$1/$2"}) {
                $gInterfacesWithoutTrunk->{"$1/$2"} = $free;
                $gNumberOfInterfacesWithoutTrunk++;
                # look for free ports with admin status up
                if ($free and $grefhCurrent->{If}->{"$oid_ifDescr"}->{ifAdminStatus} eq 'up') {
                    $grefhCurrent->{If}->{$oid_ifDescr}->{ifLastTrafficOutOfRange} = "yellow";
                    $gNumberOfFreeUpInterfaces++;
                }
            }
        } elsif (not $oid_ifDescr =~ /^vif|Loopback|^lo/i) {
            # we look for all interfaces having speed property but not looking like a virtual interface
            if (not defined $gInterfacesWithoutTrunk->{"$oid_ifDescr"}) {
                $gInterfacesWithoutTrunk->{"$oid_ifDescr"} = $free;
                $gNumberOfInterfacesWithoutTrunk++;
                # look for free ports with admin status up
                if ($free and $grefhCurrent->{If}->{"$oid_ifDescr"}->{ifAdminStatus} eq 'up') {
                    $grefhCurrent->{If}->{$oid_ifDescr}->{ifLastTrafficOutOfRange} = "yellow";
                    $gNumberOfFreeUpInterfaces++;
                }
            }
        } 
    }
    logger(1, "ifDescr: $oid_ifDescr\tFreeUp: $gNumberOfFreeUpInterfaces\tWithoutTrunk: $gNumberOfInterfacesWithoutTrunk");
}

# ------------------------------------------------------------------------------
# Csv2Html
# This function generates a html table
#
# Function call:
# $gHtml   = Csv2Html ($refaHeader,$refaLines);
# ------------------------------------------------------------------------------
sub Csv2Html {
    my $refaHeader = shift;       # Header contains the HTML table header as scalar
    my $refaLines  = shift;       # Reference to array of table lines
	my $cssClass   = shift;       # Css class to use for the table
	
    my $refaProperties;           # List of properties from each line
    my $HTML;                     # HTML Content back to the caller
    my $HTMLTable;                # HTML Table code only
    my $FS = ';';

    if ($#$refaLines >= 0) {

        # Build HTML format and table header
        $HTML .= '<a name=top></a>'."\n";
        $HTML .= '<br>';
        $HTML .= '<span>'."\n";
        $HTML .= '<table '."class=$cssClass";
		if ($cssClass eq "interfacetable") {
			$HTML .= ' onMouseOver="javascript:trackTableHighlight(event, ' . "'#81BEF7'" . ');" onMouseOut="javascript:highlightTableRow(0);"';
		}
		$HTML .= '>'."\n";
		
        # Build html table title header
        #
        # - $Header looks like this:
        # index;Description;Alias;AdminStatus;OperStatus;Speed;IP
        #
        # - It will be transformed to:
        # <th>index</th><th>Description</th><th>Alias</th> ...
        $HTML .= "<th>$_</th>" for ( @$refaHeader );

        foreach my $Line ( @$refaLines ) {
            #logger(3, "CSVline: " . Dumper ($Line));
            # start table line ---------------------------------------------
            $HTMLTable .= "<tr";
            my $trTagclose = '>';

            foreach my $Cell ( @$Line ) {

                my $Value;
                my $SpecialCellFormat      = "";
                #my $SpecialTextFormatHead  = "";
                #my $SpecialTextFormatFoot  = "";

                if ( defined $Cell->{InterfaceGraphURL} ) {
                    if($ghOptions{'enableperfdata'}){         # thd
                        $HTMLTable .= ' onclick="DoNav(\''.$Cell->{InterfaceGraphURL}. '\');" >';
                    }
                    $trTagclose = '';
                }
                $HTMLTable .= $trTagclose;
                $trTagclose = '';
                #logger(1, "HTMLTable: $HTMLTable \nCell: $Cell->{InterfaceGraphURL}");
                # if background is defined ---------------------------------
                if ( defined $Cell->{Background} ) {
                    $SpecialCellFormat .= ' bgcolor="'.$Cell->{Background}.'"';
                }
				
				# if style is defined ---------------------------------
                if ( defined $Cell->{Style} ) {
                    $SpecialCellFormat .= ' class="'.$Cell->{Style}.'"';
                }

                # if a special font is indicated ---------------------------
                #if ( defined $Cell->{Font} ) {
                #    $SpecialTextFormatHead .= $Cell->{Font};
                #    $SpecialTextFormatFoot .= '</font>';
                #}

                # if we got a value write into cell ------------------------
                if ( defined $Cell->{Value} and  $Cell->{Value} ne " ") {
                    $Value = $Cell->{Value};
                } else {
                # otherwise create a empty cell ----------------------------
                    $Value = "&nbsp;";
                }

                # if a link is indicated -----------------------------------
                if ( defined $Cell->{Link} ) {
                    $Value = '<a href="' . $Cell->{Link} . '">' . $Value . '</a>';
                }

                # finally build the table line;
                $HTMLTable .= "\n" . '<td ' . 
				    $SpecialCellFormat . '>' .
                    #$SpecialTextFormatHead . 
					$Value .
                    #$SpecialTextFormatFoot . 
					'</td>';
            }
            # end table line -----------------------------------------------
            $HTMLTable .= "</tr>";
        }
         $HTMLTable .= "</table>";
         $HTML .= "$HTMLTable</td></tr><br>";
    } else {
        $HTML.='<a href=JavaScript:history.back();>No data to display</a>'."\n";
    }

    return $HTML;
}

# ------------------------------------------------------------------------------
# AppendLinkToText
# Apend html table link to text
# ------------------------------------------------------------------------------
sub AppendLinkToText {

    my $refhStruct = shift;
    my $ResultText;

    #$ResultText = '<a href="' . "$refhStruct->{HtmlUrl}/$refhStruct->{File}" . '">' . $refhStruct->{Text} . '</a>';

    #Modified output to avoid problems with addons not handling html links correctly (ex: nagstamon)
    $ResultText = $refhStruct->{Text} . ' <a href="' . "$refhStruct->{HtmlUrl}/$refhStruct->{File}" . '">[details]</a>';

    return $ResultText;
}

# ------------------------------------------------------------------------------
# ExitPlugin
# Print correct output text and exit this plugin now
# ------------------------------------------------------------------------------
sub ExitPlugin {

    my $refhStruct = shift;

    # --------------------------------------------------------------------
    # when we have UNKNOWN the exit code and the text can
    # be overwritten from the command line with the options
    # -UnknownExit and -UnknownText
    #
    # Example for CRITICAL (code=2):
    #
    # ...itd_check_xxxxx.pl -UnknownExit 2 -UnknownText "Error getting data"
    #
    if ($refhStruct->{ExitCode} == $ERRORS{'UNKNOWN'}) {
        $refhStruct->{ExitCode} = $refhStruct->{UnknownExit};
        $refhStruct->{Text}     = $refhStruct->{UnknownText};
    }

    print $refhStruct->{Text};
    print "|";
    if ($ghOptions{'enableperfdata'} and $basetime) {
        print "Interface_global::check_interface_table_global::" .
                "time=${TimeDiff}s;;;; " .
                "uptime=$grefhCurrent->{MD}->{sysUpTime}s;;;; " .
                "watched=${gNumberOfPerfdataInterfaces};;;; " .
                "useddelta=${gUsedDelta}s;;;; " .
                "ports=${gNumberOfInterfacesWithoutTrunk};;;; " .
                "freeports=${gNumberOfFreeInterfaces};;;; " .
                "adminupfree=${gNumberOfFreeUpInterfaces};;;; ";
        unless ($ghOptions{'perfdatashort'}) {
            print "$gPerfdata\n";
        }
    }

    exit $refhStruct->{ExitCode};
}

# ------------------------------------------------------------------------------
# Append Buttons
# ------------------------------------------------------------------------------
sub HtmlLinks {

    my $refhStruct          = shift;
    my $Text                = shift;
    my $InterfaceStateFile  = "$refhStruct->{ResetTable}";
    my $HTML;

    # nice font
    $HTML.='<span>'."\n";

    # back button
    if ($refhStruct->{Back}) {
        $HTML.='<a href="JavaScript:history.back();">[ back ]</a>'."\n";
    }

    # reset button to remove file
    if ($InterfaceStateFile) {
        if (-f "$InterfaceStateFile") {
            $HTML.="<a href=\"$ghOptions{reseturl}/InterfaceTableReset_v3t.cgi?Command=rm&What=$InterfaceStateFile\">[ reset table ]</a>";
        }
    }

    $HTML.='</span>'."\n";

    return $HTML;
}

# ------------------------------------------------------------------------
# various functions reporting plugin information & usages
# ------------------------------------------------------------------------
sub print_usage () {
  print <<EOUS;

  Usage:

    * basic usage:
      $PROGNAME [-vvv] -H <hostname/IP> [-h <host alias>] [--community <community string>] 
        [-e <interface exclusion list>] [-i <interface inclusion list>] [-t <property list>] [-r]
        [-w <warning change counter>] [-c <critical change counter>] [-W <warning load prct>] 
        [-C <critical load prct>] [-f] [-g <grapher solution>] [--outputshort]

    * advanced usage:
      $PROGNAME [-vvv] [-t <timeout>] -H <hostname/IP> [-h <host alias>] [--community <community string>] 
        [-e <interface exclusion list>] [-i <interface inclusion list>] [-t <property list>] [-r]
        [-w <warning change counter>] [-c <critical change counter>] [-W <warning load prct>] 
        [-C <critical load prct>] [-f] [-g <grapher solution>] [--outputshort]
        [--cachedir <caching directory>] [--statedir <state files directory>] [--vlan] [--cisco]
        [--accessmethod <method>] [--htmltabledir <system path to html interface tables>] 
        [--htmltableurl <url to html interface tables>] [-d <delta>] [--ifs <separator>] 
        [--cache <cache retention time>] [--reseturl <url to reset cgi>] [--(no)ifloadgradient] 
        [--(no)human] [--(no)snapshot] [--portperfunit <unit>] [--grapherurl <url to grapher>]
        [-E <interface perfdata exclusion list>] [-I <interface perfdata inclusion list>]

    * other usages:
      $PROGNAME [--help | -?]
      $PROGNAME [--version | -V]
      $PROGNAME [--showdefaults | -D]

  Common options:
    --help | -?
        Show this help page
    --version | -V
        Plugin version
    --verbose | -v
        Verbose mode. Can be specified multiple times to increase the verbosity (max 3 times).
    --showdefaults | -D
        Print the option default values
    --hostquery | -H (required)
        Specifies the remote host to poll.
    --hostdisplay | -h (optional)
        Specifies the remote host to display in the HTML link.
        If omitted, it defaults to the host with -H
    --community (required)
        Specifies the snmp v1 community string. Other snmp versions are not
        implemented yet.
    --exclude | -e (optional)
        Comma separated list of interfaces excluded from tracking. Can be used to exclude:
         * virtual or loopback interfaces
         * flapping interfaces
    --include | -i (optional)
        Comma separated list of interfaces included for tracking. By default, all the 
        interfaces are included. But there are some case where you need to include an 
        interface which is part of a group of previously excluded interfaces.
    --track | -t (optional)
        List of tracked properties. Values can be:
         * 'ifAdminStatus'      : the administrative status of the interface
         * 'ifOperStatus'       : the operational status of the interface
         * 'ifSpeedReadable'    : the speed of the interface
         * 'ifVlanNames'        : the vlan on which the interface was associated
         * 'IpInfo'             : the ip configuration for the interface
        Default is 'ifOperStatus'
        Note: interface traffic load(s) is not considered as a property, and is always 
              monitored following defined thresholds. 
    --regexp | -r (optional)
        Interface names and property names for some other options will be interpreted as
        regular expressions.
    --warning | -w (optional)
        Number of property changes before leading to a warning alert
    --critical | -c (optional)
        Number of property changes before leading to a critical alert
    --warning-load | -W (optional)
        Interface traffic load percentage leading to a warning alert 
    --critical-load | -C (optional)
        Interface traffic load percentage leading to a critical alert 
    --enableperfdata | -f (optional)
        Enable port performance data, default is port perfdata disabled
    --grapher (optional)
        Specify the used graphing solution. 
        Can be pnp4nagios, nagiosgrapher or netwaysgrapherv2.
    --outputshort (optional)
        Reduce the verbosity of the plugin output. If used, the plugin only returns 
        general counts (nb ports, nb changes,...). This is close to the way the 
        previous versions of the plugin was working.
        
        In this version of the plugin, by default the plugin returns 
        + general counts (nb ports, nb changes,...) 
        + what changes has been detected 
        + what interface(s) suffer(s) from high load.
    
  Advanced options:
    --cachedir (optional)
        Sets the directory where snmp responses are cached.
    --statedir (optional)
        Sets the directory where the interface states are stored.
    --vlan (optional)
        Add the vlan attribution property for each interface in the interface table.
    --cisco (optional)
        Add cisco specific info in the information table.
    --accessmethod (optional)
        Access method for the link to the host in the HTML page.
        Can be ssh or telnet.
    --htmltabledir (optional)
        Specifies the directory in the file system where HTML interface table are stored.
    --htmltableurl (optional)
        Specifies the URL by which the interface table are accessible.
    --delta | -d (optional)
        Set the delta used for interface throuput calculation. In seconds.
    --ifs (optional)
        Input field separator. The specified separator is used for all options allowing
        a list to be specified.
    --cache (optional)
        Define the retention time of the cached data. In seconds.
    --reseturl (optional)
        Specifies the URL to the tablereset program.
    --(no)ifloadgradient (optional)
        Enable color gradient from green over yellow to red for the load percentage 
        representation. Default is enabled.
    --(no)human (optional)
        Translate bandwidth usage in human readable format (G/M/K bps). Default is enabled.
    --(no)snapshot (optional)
        Force the plugin to run like if it was the first launch. Cached data will be 
        ignored. Default is enabled.
    --timeout (optional)
        Define the timeout limit of the plugin.
    --exclude-property | -E (optional)
        Comma separated list of interfaces excluded from the property tracking. 
    --include-property | -I (optional)
        Comma separated list of interfaces included in the property tracking. 
        By default, all the interfaces that are tracked are included. But there are some 
        case where you need to include an interface which is part of a group of previously 
        excluded interfaces.
    --portperfunit (optional)
        In/out traffic in perfdata could be reported in octets or in bits.
        Possible values: bit or octet
    --grapherurl (optional)
        Graphing system url. Default values are:
         * pnp4nagios       : /pnp4nagios
         * nagiosgrapher    : /nagios/cgi-bin (?)
         * netwaysgrapherv2 : /nagios/cgi-bin (?)

  Notes:
    - For options --track, --exclude, --include, --excludeportperf, --includeportperf:
       * These options can be used multiple times, the lists of interfaces/properties 
         will be concatenated.
       * The separator can be changed using the --ifs option.
	- The manual is included in this plugin in pod format. To read it, use the perldoc
      program (if not installed, just intall the perl-doc package):
      perldoc ./check_interface_table_v3t.pl
        
EOUS

}
sub print_defaults () {
  print "Default option values:\n\n";
  print Dumper(\%ghOptions);
}
sub print_help () {
  print "Copyright (c) 2011 Yannick Charton\n\n";
  print "\n";
  print "  Check various statistics of network interfaces \n";
  print "\n";
  print_usage();
  support();
}
sub print_revision ($$) {
  my $commandName = shift;
  my $pluginRevision = shift;
  $pluginRevision =~ s/^\$Revision: //;
  $pluginRevision =~ s/ \$\s*$//;
  print "$commandName ($pluginRevision)\n";
  print "This nagios plugin comes with ABSOLUTELY NO WARRANTY. You may redistribute\ncopies of this plugin under the terms of the GNU General Public License version 3 (GPLv3).\n";
}
sub support () {
  my $support='Send email to tontonitch-pro@yahoo.fr if you have questions\nregarding the use of this plugin. \nPlease include version information with all correspondence (when possible,\nuse output from the -V option of the plugin itself).\n';
  $support =~ s/@/\@/g;
  $support =~ s/\\n/\n/g;
  print $support;
}

# ------------------------------------------------------------------------
# command line options processing
# ------------------------------------------------------------------------
sub check_options () {
    my %commandline = ();
    my @params = (
        'hostdisplay|h=s',
        'hostquery|H=s',
        'help|?',
        'verbose|v+',
        'showdefaults|D',						# print all option default values
        'cachedir=s',                           # caching directory
        'statedir=s',                           # interface table state directory
        'accessmethod=s',                       # access method for the link to the host in the HTML page
        'htmltabledir=s',                       # interface table HTML directory
        'htmltableurl=s',                       # interface table URL location
        'exclude-traffic|et=s@',                       # list of interfaces excluded from the load tracking
        'include-traffic|it=s@',                       # list of interfaces included in the load tracking
        'warning|wt=s',
        'critical|ct=s',
        'community=s',                          # community string
        'delta|d=i',                            # interface throuput delta in seconds
        'ifs=s',                                # input field separator
        'cache=s',                              # cache timer
        'reseturl=s',                           # URL to tablereset program
        'vlan',                                 # Add vlan attribution info for each interface
        'cisco',                                # Add cisco specific info in the info table
        'ifloadgradient!',                      # color gradient from green over yellow to red representing the load percentage
        'human!',                               # translate bandwidth usage in human readable format (G/M/K bps)
        'trackprop|tp=s@',                      # list of tracked properties
        'exclude-property|ep=s@',                       # list of interfaces excluded from the property tracking
        'include-property|ip=s@',                       # list of interfaces included in the property tracking
        'warning-property|wp=i',
        'critical-property|cp=i',
        'snapshot!',
        'version|V',
        'regexp|r',
        'outputshort',                          # the plugin only returns general counts (nb ports, nb changes,...). 
                                                # By default, the plugin returns general counts (nb ports, nb changes,...) 
                                                # + what changes has been detected
        'enableperfdata|f',                     # enable port performance data, default is port perfdata disabled
        'portperfunit=s',                       # bit|octet: in/out traffic in perfdata could be reported in octets or in bits
        'perfdatashort',                        # restrict the performance data to the global statistics. Statistics specific 
                                                # to each interfaces will be not returned.
        'grapher|g',                            # graphing system. Can be pnp4nagios, nagiosgrapher or netwaysgrapherv2
        'grapherurl',                           # graphing system url. By default, this is adapted for pnp4nagios standard install: /pnp4nagios
        # SNMP related
        'port|p=i',
        'community|C=s',
        'v2c|2',
        'snmp-login|l=s',
        'passwd|x=s',
        'privpass|X=s',
        'protocols|L=s',
        'timeout|t=i'
        );
    # Default option values
    %ghOptions = (
        'help'                      => 0,
        'verbose'                   => 0,
        'showdefaults'              => 0,
        'hostquery'                 => '',
        'hostdisplay'               => '',
        'cachedir'                  => "@cachedir@",
        'statedir'                  => "@statedir@",
        'accessmethod'              => "ssh",
        'htmltabledir'              => "@htmldir@/tables",
        'htmltableurl'              => "@htmlurl@/tables",
        'exclude-traffic'           => undef,
        'include-traffic'           => undef,
        'warning'                   => "101,0,0",
        'critical'                  => "101,0,0",
        'community'                 => "public",
        'delta'                     => 600,
        'ifs'                       => ',',
        'cache'                     => 3600,
        'reseturl'                  => "@cgiurl@",
        'vlan'                      => 0,
        'cisco'                     => 0,
        'ifloadgradient'            => 1,
        'human'                     => 1,
        'snapshot'                  => 0,
        'track'                     => ['ifOperStatus'],     # can be compared: ifAdminStatus, ifOperStatus, ifSpeedReadable, ifVlanNames, IpInfo
        'exclude-property'          => undef,
        'include-property'          => undef,
        'warning-property'          => 0,
        'critical-property'         => 0,
        'regexp'                    => 0,
        'timeout'                   => $TIMEOUT,
        'outputshort'               => 0,
        'enableperfdata'            => 0,
        'portperfunit'              => "bit",
        'perfdatashort',            => 0,
        'grapher'                   => "pnp4nagios",
        'grapherurl'                => ""
    );
    # set the default grapher url depending to the selected grapher
    my %defaultgrapherurl = (
        'pnp4nagios'        => '/pnp4nagios', 
        'nagiosgrapher'     => '/nagios/cgi-bin',
        'netwaysgrapherv2'  => '/nagios/cgi-bin'
        );
    $ghOptions{'grapherurl'} = "$defaultgrapherurl{$ghOptions{grapher}}";
    # gathering commandline options
    if (! GetOptions(\%commandline, @params)) {
        print_help();
        exit $ERRORS{UNKNOWN};
    }
    ### mandatory commandline options: hostquery
    # applying commandline options
    if (exists $commandline{verbose}) {
        $ghOptions{'verbose'} = $commandline{verbose};
        setLoglevel($commandline{verbose});
    }
    if (exists $commandline{version}) {
        print_revision($PROGNAME, $REVISION);
        exit $ERRORS{OK};
    }
    if (exists $commandline{help}) {
        print_help();
        exit $ERRORS{OK};
    }
    if (exists $commandline{showdefaults}) {
        print_defaults();
        exit $ERRORS{OK};
    }
    if (exists $commandline{timeout}) {
        $ghOptions{'timeout'} = $commandline{timeout};
        $TIMEOUT = $ghOptions{'timeout'};
    }
    if (exists $commandline{ifs}) {
        $ghOptions{'ifs'} = "$commandline{ifs}";
    }
    if (! exists $commandline{'hostquery'}) {
        print "host to query not defined (-H)\n";
        print_help();
        exit $ERRORS{UNKNOWN};
    } else {
        $ghOptions{'hostquery'} = "$commandline{hostquery}";
    }
    if (exists $commandline{hostdisplay}) {
        $ghOptions{'hostdisplay'} = "$commandline{hostdisplay}";
    } else {
        $ghOptions{'hostdisplay'} = "$commandline{hostquery}";
    }
    if (exists $commandline{cachedir}) {
        $ghOptions{'cachedir'} = "$commandline{cachedir}";
    }
	$ghOptions{'cachedir'} = "$ghOptions{'cachedir'}/$commandline{hostquery}";
    -d "$ghOptions{'cachedir'}" or MyMkdir ("$ghOptions{'cachedir'}");
    if (exists $commandline{statedir}) {
        $ghOptions{'statedir'} = "$commandline{statedir}";
    }
	$ghOptions{'statedir'} = "$ghOptions{'statedir'}/$commandline{hostquery}";
    -d "$ghOptions{'statedir'}" or MyMkdir ("$ghOptions{'statedir'}");
    if (exists $commandline{accessmethod} and ($commandline{accessmethod} eq "ssh" or $commandline{accessmethod} eq "telnet")) {
        $ghOptions{'accessmethod'} = "$commandline{accessmethod}";
    }
	if (exists $commandline{enableperfdata}) {
        $ghOptions{'enableperfdata'} = 1;
    }
    if (exists $commandline{portperfunit} and ($commandline{portperfunit} eq "bit" or $commandline{portperfunit} eq "octet")) {
        $ghOptions{'portperfunit'} = "$commandline{portperfunit}";
    }
    # organizing excluded/included interfaces for load tracking
    if (exists $commandline{'exclude-traffic'}) {
        my @tmparray = split("$ghOptions{ifs}", join("$ghOptions{ifs}",@{$commandline{'exclude-traffic'}}));
        $ghOptions{'exclude-traffic'} = \@tmparray;
    } 
    if (exists $commandline{'include-traffic'}) {
        my @tmparray = split("$ghOptions{ifs}", join("$ghOptions{ifs}",@{$commandline{'include-traffic'}}));
        $ghOptions{'include-traffic'} = \@tmparray;
    }
    # organizing tracked fields
    if (exists $commandline{track}) {
        my @tmparray = split("$ghOptions{ifs}", join("$ghOptions{ifs}",@{$commandline{track}}));
        $ghOptions{'track'} = \@tmparray;
    }
    # organizing excluded/included interfaces for property(ies) tracking
    if (exists $commandline{'exclude-property'}) {
        my @tmparray = split("$ghOptions{ifs}", join("$ghOptions{ifs}",@{$commandline{'exclude-property'}}));
        $ghOptions{'exclude-property'} = \@tmparray;
    } 
    if (exists $commandline{'include-property'}) {
        my @tmparray = split("$ghOptions{ifs}", join("$ghOptions{ifs}",@{$commandline{'include-property'}}));
        $ghOptions{'include-property'} = \@tmparray;
    }
    if (exists $commandline{regexp}) {
        $ghOptions{'regexp'} = $commandline{regexp};
    }
    if (exists $commandline{htmltabledir}) {
        $ghOptions{'htmltabledir'} = "$commandline{htmltabledir}";
    }
    if (exists $commandline{htmltableurl}) {
        $ghOptions{'htmltableurl'} = "$commandline{htmltableurl}";
    }
    if (exists $commandline{community}) {
        $ghOptions{'community'} = "$commandline{community}";
    }
    if (exists $commandline{delta}) {
        $ghOptions{'delta'} = "$commandline{delta}";
    }
    if (exists $commandline{cache}) {
        $ghOptions{'cache'} = "$commandline{cache}";
    }
    if (exists $commandline{reseturl}) {
        $ghOptions{'reseturl'} = "$commandline{reseturl}";
    }
    if (exists $commandline{ifloadgradient}) {
        $ghOptions{'ifloadgradient'} = 1;
    }
    if (exists $commandline{human}) {
        $ghOptions{'human'} = 1;
    }
    if (exists $commandline{vlan}) {
        $ghOptions{'vlan'} = 1;
    }
    if (exists $commandline{cisco}) {
        $ghOptions{'cisco'} = 1;
    }
    if (exists $commandline{snapshot}) {
        $ghOptions{'snapshot'} = 1;
    }
    if (exists $commandline{warning}) {
        $ghOptions{'warning'} = "$commandline{warning}";
    }
    my @tmparray2=split(/,/,$ghOptions{'warning'});
    if ($#tmparray2 != 2) {
        print "3 warning levels needed! (i.e. --warning 101,0,0)";
        exit $ERRORS{"UNKNOWN"};
    }
    $ghOptions{'warning-load'} = $tmparray2[0];
    $ghOptions{'warning-load'} =~ s/%$//;
    $ghOptions{'warning-pkterr'} = $tmparray2[1];
    $ghOptions{'warning-pktdiscard'} = $tmparray2[2];
    if (exists $commandline{critical}) {
        $ghOptions{'critical'} = "$commandline{critical}";
    }
    my @tmparray3=split(/,/,$ghOptions{'critical'});
    if ($#tmparray3 != 2) {
        print "3 critical levels needed! (i.e. --critical 101,0,0)";
        exit $ERRORS{"UNKNOWN"};
    }
    $ghOptions{'critical-load'} = $tmparray3[0];
    $ghOptions{'critical-load'} =~ s/%$//;
    $ghOptions{'critical-pkterr'} = $tmparray3[1];
    $ghOptions{'critical-pktdiscard'} = $tmparray3[2];
    if (exists $commandline{outputshort}) {
        $ghOptions{'outputshort'} = 1;
    }
    if (exists $commandline{grapher}) {
        if ($commandline{grapher} =~ /^pnp4nagios$|^nagiosgrapher$|^netwaysgrapherv2$/i) {
            $ghOptions{'grapher'} = "$commandline{grapher}";
        }
    }
    if (exists $commandline{grapherurl}) {
        $ghOptions{'grapherurl'} = "$commandline{grapherurl}";
    } else {
        $ghOptions{'grapherurl'} = "$defaultgrapherurl{$ghOptions{grapher}}";
    }
    
    # print the options in command line, and the resulting full option hash
    logger(3, "commandline\n".Dumper(\%commandline));
    logger(3, "options\n".Dumper(\%ghOptions));
}

__END__

=head1 NAME

  check_interface_table_v3t.pl - nagios plugin for monitoring network devices

=head1 SYNOPSIS

  check_interface_table_v3t.pl -H <hostname/IP> [-h <host alias>] [-C <community string>] 
        [-e <interface exclusion list>] [-i <interface inclusion list>] [-t <property list>] [-r]
        [-w <warning change counter>] [-c <critical change counter>] [-w <warning load prct>] 
        [-c <critical load prct>] [-f] [-g <grapher solution>] [--outputshort]

=head1 DESCRIPTION

=head2 Introduction

B<check_interface_table_v3t.pl> is a Nagios(R) plugin that allows you to monitor
the network devices of various nodes (e.g. router, switch, server) without knowing 
each interface in detail. Only the hostname (or ip address) and the snmp community 
string are required.

  Simple Example:
  C<# check_interface_table_v3t.pl -H server1 -C public>

  Output:
  C<<a href="/nagios/interfacetable/server1-Interfacetable.html">total 3 interface(s)</a>>

The output is a HTML link to a web page which shows all interfaces in a table.

=head2 Theory of operation

The perl program polls the remote machine in a highly efficient manner.
It collects all data from all interfaces and stores these data into "state" files in a
specific directory (ex: /tmp/.ifState).

Each host (option -H) holds one text file:
  # ls /tmp/.ifState/*.txt
  /tmp/.ifState/server1-Interfacetable.txt

When the program is called twice, three times, etc. it retreives new
information from the network and compares it against this state file.

=head1 PREREQUISITS

This chapter describes the operating system prerequisits to get this program
running:

=head2 net-snmp software

The B<snmpwalk> command must be available on your operating system.

Test your snmpwalk output with a command like:

  # snmpwalk -Oqn -v 1 -c public router.itdesign.at | head -3
    .1.3.6.1.2.1.1.1.0 Cisco IOS Software, 2174 Software Version 11.7(3c), REL.
    SOFTWARE (fc2)Technical Support: http://www.cisco.com/techsupport
    Copyright (c) 1986-2005 by Cisco Systems, Inc.
    Compiled Mon 22-Oct-03 9:46 by antonio
    .1.3.6.1.2.1.1.2.0 .1.3.6.1.4.1.9.1.620
    .1.3.6.1.2.1.1.3.0 9:11:09:19.48

  snmpwalk parameters:
    -Oqn -v 1 ............ some noise (please read "man snmpwalk")
    -c public  ........... snmp community string
    router.itdesign.at ... host where you do the snmp queries

B<snmpwalk> is part of the net-snmp suit (http://net-snmp.sourceforge.net/).
Some more unix commands to find it:

  # whereis snmpwalk
  snmpwalk: /usr/bin/snmpwalk /usr/share/man/man1/snmpwalk.1.gz

  # which snmpwalk
  /usr/bin/snmpwalk

  # rpm -qa | grep snmp
  net-snmp-5.3.0.1-25.15

  # rpm -ql net-snmp-5.3.0.1-25.15 | grep snmpwalk
  /usr/bin/snmpwalk
  /usr/share/man/man1/snmpwalk.1.gz

=head2 PERL v5 installed

You need a working perl 5.x installation. Currently we use V5.8.8 under
SUSE Linux Enterprise Server 10 SP1 for development. We know that it works
with other versions, too.

Get your perl version with:
  # perl -V

=head2 PERL modules

=head3 PERL Net::SNMP library

B<Net::SNMP> is the perl's snmp library. Some ideas to see if it is installed:

  For RedHat, Fedora, SuSe:
  # rpm -qa|grep -i perl|grep -i snmp
  perl-Net-SNMP-5.2.0-12.2

  # find /usr -name SNMP.pm
  /usr/lib/perl5/vendor_perl/5.8.8/Net/SNMP.pm

  if it is not installed please check your operating systems packages or install it
  from CPAN: http://search.cpan.org/search?query=Net%3A%3ASNMP&mode=all

=head3 PERL Config::General library

B<Config::General> is used to write all interface information data back to the 
file system.

This perl library should be available via the package management tool of your 
system distribution.
  
  For Debian distribution:
  # apt-get install libconfig-general-perl
  
  CPAN page: http://search.cpan.org/search?query=Config%3A%3AGeneral&mode=all

=head3 PERL Data::Dumper library

B<Data::Dumper> is used to easily dump hashes and arrays in some parts of the debug.

This perl library should be available via the package management tool of your 
system distribution.
  
  For Debian distribution:
  # apt-get install libdata-dump-perl
  
  CPAN page: http://search.cpan.org/search?query=Data%3A%3ADumper&mode=all

=head3 PERL Getopt::Long library

B<Getopt::Long> is used to handle the commandline options of the plugin.

This perl library should already be available on your system.
  
  For Debian distribution:
  # apt-get install libdata-dump-perl
  
  CPAN page: http://search.cpan.org/search?query=Getopt%3A%3ALong&mode=all
  
=head2 CGI script to reset the interface table

If everything is working fine you need the possibility to reset the interface table.
Often it is necessary that someone changes ip addresses or other properties. These
changes are necessary and you want to update (=reset) the table.

Resetting the table means to delete the state file (ex: in /tmp/.ifState).

Withing this kit you find an example shell script which does this job for you.
To install this cgi script do the following:

  1) Copy the cgi script to the correct location on your WEB server
  # cp -i InterfaceTableReset_v3t.cgi /usr/local/nagios/sbin

  2) Check permissions
  # ls -l /usr/local/nagios/sbin/InterfaceTableReset_v3t.cgi
  -rwxr-xr-x 1 nagios nagios 2522 Nov 16 13:14 /usr/local/nagios/sbin/Inte...

  3) Prepare the /etc/sudoers file so that the web server's account can call
  the cgi script (as shell script)
    Suse linux based distrib:
        # visudo
        wwwrun ALL=(ALL) NOPASSWD: /usr/local/nagios/sbin/InterfaceTableReset_v3t.cgi
    Debian based distrib:
        # visudo
        www-data ALL=(ALL) NOPASSWD: /usr/local/nagios/sbin/InterfaceTableReset_v3t.cgi

The above unix commands are tested with apache2 installed and nagios v3 compiled 
into /usr/local/nagios.

Note: please send me an email if you have information from other operating systems
on these details. I will update the documentation.

=head2 Configure Nagios 3.x to display HTML links in Plugin Output

In Nagios version 3.x there is html output per default disabled.

  1) Edit cgi.cfg and set this option to zero
      escape_html_tags=0

cgi.cfg is located in your configuration directory. (ex: /usr/local/nagios/etc)

=head1 OPTIONS

=head2 Basic options

=head3 --help | -?

 Show this help page

=head3 --man | --manual

 Print the manual

=head3 --version | -V

 Plugin version
 
=head3 --verbose | -v

 Verbose mode. Can be specified multiple times to increase the verbosity (max 3 times).

=head3 --showdefaults | -D

 Print the option default values

=head3 --hostquery | -H (required)

 No default
 Specifies the remote host to poll.

=head3 --hostdisplay | -h (optional)

 Default = <hostquery>
 Specifies the remote host to display in the HTML link.
 If omitted, it defaults to the host with -H

 Example:
    check_interface_table_v3t.pl -h firewall -H srv-itd-99.itdesign.at -C mkjz65a

 This option is maybe useful when you want to poll a host with -H and display
 another link for it.
 
=head3 --community (required)

 Default = public
 Specifies the snmp v1 community string. Other snmp versions are not
 implemented yet.

=head3 --exclude-traffic | -e (optional)

 Comma separated list of interfaces excluded from load tracking (main check). Can 
 be used to exclude:
  * virtual or loopback interfaces
  * flapping interfaces
 
 Example:
    ... -H router -C public -e Dialer0,BVI20,FastEthernet0
 
 Note: if --regexp is not used, the interface descriptions must match exactly!

=head3 --include-traffic | -i (optional)

 Comma separated list of interfaces included in load tracking (main check). By 
 default, all the interfaces are included. But there are some case where you 
 need to include an interface which is part of a group of previously excluded 
 interfaces.
 
 Example:
    ... -H router -C public -i FastEthernet0,FastEthernet1

 Note: if --regexp is not used, the interface descriptions must match exactly!

=head3 --track | -t (optional)

 List of tracked properties. Values can be:
  * 'ifAdminStatus'      : the administrative status of the interface
  * 'ifOperStatus'       : the operational status of the interface
  * 'ifSpeedReadable'    : the speed of the interface
  * 'ifVlanNames'        : the vlan on which the interface was associated
  * 'IpInfo'             : the ip configuration for the interface
 Default is 'ifOperStatus'
 Note: interface traffic load(s) is not considered as a property, and is always 
       monitored following defined thresholds. 

=head3 --regexp | -r (optional)

 Interface names and property names for some other options will be interpreted as
 regular expressions.

=head3 --warning | -w (optional)

 Must be a positive integer number. Changes in the interface table are compared
 against this threshold.
 Example:
    ... -H server1 -C public -w 1
 Leads to WARNING (exit code 1) when one or more interface properties were
 changed.

=head3 --critical | -c (optional)

 Must be a positive integer number. Changes in the interface table are compared
 against this threshold.
 Example:
    ... -H server1 -C public -c 1
 Leads to CRITICAL (exit code 2) when one or more interface properties were
 changed.

=head3 --warning-load | -W (optional)

 Interface traffic load percentage leading to a warning alert 

=head3 --critical-load | -C (optional)

 Interface traffic load percentage leading to a critical alert 

=head3 --enableperfdata | -f (optional)

 Enable performance data, default is port perfdata disabled

=head3 --grapher (optional)

 Specify the used graphing solution. 
 Can be pnp4nagios, nagiosgrapher or netwaysgrapherv2.

=head3 --outputshort (optional)

 Reduce the verbosity of the plugin output. If used, the plugin only returns 
 general counts (nb ports, nb changes,...). This is close to the way the 
 previous versions of the plugin was working.
 
 In this version of the plugin, by default the plugin returns 
   + general counts (nb ports, nb changes,...) 
   + what changes has been detected 
   + what interface(s) suffer(s) from high load.
    
=head2 Advanced options

=head3 --cachedir (optional)

 Sets the directory where snmp responses are cached.

=head3 --statedir (optional)

 Sets the directory where the interface states are stored.

=head3 --vlan (optional)

 Add the vlan attribution property for each interface in the interface table.

=head3 --cisco (optional)

 Add cisco specific info in the information table.

=head3 --accessmethod (optional)

 Access method for the link to the host in the HTML page.
 Can be ssh or telnet.

=head3 --htmltabledir (optional)

 Specifies the directory in the file system where HTML interface table are stored.
=head3 --htmltableurl (optional)

 Specifies the URL by which the interface table are accessible.
=head3 --delta | -d (optional)

 Set the delta used for interface throuput calculation. In seconds.
=head3 --ifs (optional)

 Input field separator. The specified separator is used for all options allowing
 a list to be specified.

=head3 --cache (optional)

 Define the retention time of the cached data. In seconds.

=head3 --reseturl (optional)

 Specifies the URL to the tablereset program.

=head3 --(no)ifloadgradient (optional)

 Enable color gradient from green over yellow to red for the load percentage 
 representation.

=head3 --(no)human (optional)

 Translate bandwidth usage in human readable format (G/M/K bps).

=head3 --(no)snapshot (optional)

 Force the plugin to run like if it was the first launch. Cached data will be 
 ignored.

=head3 --timeout (optional)

 Define the timeout limit of the plugin.

=head3 --exclude-property | -E (optional)

 Comma separated list of interfaces excluded from the property tracking.
 
=head3 --include-property | -I (optional)

 Comma separated list of interfaces included in the property tracking. 
 By default, all the interfaces that are included in the load tracking (-i option) are
 also included in the property tracking.
 Also, there are some case where you need to include an interface which is part of a 
 group of previously excluded interfaces. In this case, you need to proviously exclude 
 all/part the interfaces using -E, then includes some of them back using -I.

=head3 --portperfunit (optional)

 In/out traffic in perfdata could be reported in octets or in bits.
 Possible values: bit or octet

=head3 --grapherurl (optional)

 Graphing system url. Default values are:
  * pnp4nagios       : /pnp4nagios
  * nagiosgrapher    : /nagios/cgi-bin (?)
  * netwaysgrapherv2 : /nagios/cgi-bin (?)
 
=head1 ATTENTION - KNOWN ISSUES

=head2 Interaction with Nagios

If you use this program with Nagios then it is typically called in the "nagios"
users context. This means that the user "nagios" must have the correct permissions
to write all required files into the filesystem (see chapter "Theory of operation").

=head2 Reset table

The "reset table button" is the next challenge. Clicking in the web browser means to
trigger the "InterfaceTableReset_v3t.cgi" script which then tries to remove the state
file.

 If this does not work please check the following:

 * correct directory and permissions of InterfaceTableReset_v3t.cgi
 * correct entry in the /etc/sudoers file
 * look at /var/log/messages or /var/log/secure to see what "sudo" calls
 * look at the web servers access and error log files

=head2 /tmp cleanup

Some operating systems clean up the /tmp directory during reboot (I know that
OpenBSD does this). This leads to the problem that the /tmp/.ifState directory
is deleted and you loose your interface information states. The solution for
this is to set the -StateDir <directory> switch from command line.

=head2 umask on file and directory creation

This program generats some files and directories on demand:

  /tmp/.ifState ... directory with table states
  /tmp/.ifCache ... directory with caching data
  /usr/local/nagios/share/interfacetable ... directory with html tables

To avoid file system conflicts we simply set the umask to 0000 so that all
files and directories are created with everyone read/write permissions.

If you don't want this - change the $UMASK variable in this program and
test it very carefully - especially under the account where the program is
executed.

  Example:

  # su - nagios
  nagios> check_interface_table_v3t.pl -H <host> -C <community string> -Debug 1

=head1 LICENSE

This program was demonstrated by ITdesign during the Nagios conference in
Nuernberg (Germany) on the 12th of october 2007. Normally it is part of the
commercial suite of monitoring add ons around Nagios from ITdesign.
This version is free software under the terms and conditions of GPLV3.

Netways had adapted it to include performance data and calculate bandwidth
usage, making some features mentioned in the COMMERCIAL version available in 
the GPL version (version 2 of the plugin)
available in this GPL version.

The 3rd version (by Yannnick Charton) (version v3t, to make the distinction w
ith other possible v3 versions) brings lots of enhancements and new features 
to the v2 version. See the README and CHANGELOG files for more information.

Copyright (C) [2007]  [ITdesign Software Projects & Consulting GmbH]
Copyright (C) [2009]  [Netways GmbH]
Copyright (C) [2011]  [Yannick Charton]

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along
with this program; if not, see <http://www.gnu.org/licenses/>.

=head1 CONTACT INFORMATION

 Yannick Charton
 Email: tontonitch-pro@yahoo.fr
 Website: www.tontonitch.com

=cut
