##############################################################################
# "SnmpUtils" library
# A collection of shared functions related to snmp.
#
# Version 0.1
# Written by Y. Charton, from extracts of check_interface_table release 1-3
#
# Revision history:
# 2011-06-08 v0.1   Y. Charton    First release
#
##############################################################################

package SnmpUtils;
use strict;
use lib ('@libdir@');
use Exporter;
use GeneralUtils;

##############################################################################
### I N I T ##################################################################
##############################################################################

BEGIN {
    use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION $AUTHOR);
    @ISA         = qw(Exporter);
    @EXPORT      = qw(SnmpGet GetDataWithSnmp GetMultipleDataWithSnmp GetDataWithUnixSnmpWalk ExecuteCommand);
    @EXPORT_OK   = qw();
    $VERSION     = 0.1;
    $AUTHOR      = "Y. Charton";
}

##############################################################################
### S U B S ##################################################################
##############################################################################

sub SnmpGet {

    ################################
    # SUB use: 
    # SUB specs: 
    #  * arg 0:
    #  * return:
    ################################

    my $refhStruct = shift;

    #
    # store variables and delete them from the hash
    # this is necessary for the snmp session which takes the same
    # hash ref and does not work with arguments other than starting
    # with a dash
    #

    my $refaOIDs            = $refhStruct->{OID}; # ref to array of OIDs
    my $GlobalCacheDir      = $refhStruct->{CacheDir};
    my $GlobalCacheTimer    = $refhStruct->{CacheTimer};
    my $strict              = 0;
    
    delete $refhStruct->{OID};
    delete $refhStruct->{CacheDir};
    delete $refhStruct->{CacheTimer};

    my $refhSnmpValues; # hash returned to the caller
    my $refoSession;    # SNMP session object
    my $SessionError;   # SNMP session error
    
    # example cache dir name
    # /tmp/watchit/Cache/SnmpGet/cat-itd-01
    my $CacheDir = "$GlobalCacheDir/SnmpGet";

    # Create the directory if not existend
    not -d $CacheDir and MyMkdir($CacheDir);

    # create snmp session
    ($refoSession,$SessionError) = Net::SNMP->session (%$refhStruct);
    
    # check if any session establishment problem
    if (!defined $refoSession) {
      logger(0, "SNMP session establishment problem: ".$SessionError);
    }
    
    my $OIDLine;    # one line of OIDs or OIDs and caching timers
    my $SnmpValue;  # one snmp value

    if (defined $refoSession) {

        # OIDs come in an array (ref) - go through each
        # example:
        #    $refaOIDs = [
        #              '.1.3.6.1.2.1.2.2.1.11.1',
        #              '.1.3.6.1.2.1.2.2.1.12.1'
        #            ];
        for $OIDLine (@$refaOIDs) {

            my  $CacheTimer=0;

            $SnmpValue="";  # clear value

            # OID could be .1.3.6.1.2.1.2.2.1.11.1,200
            # <OID>,<CacheTimer> for this OID only
            my ($OID,$OIDCacheTimer) = ("","");
            ($OID,$OIDCacheTimer) = split ',',$OIDLine,2;

            if (defined $OIDCacheTimer) {
                # remove non digits
                $OIDCacheTimer =~ s/\D//g;
                if ("X$OIDCacheTimer" eq "X") { # is empty?
                    $CacheTimer = $GlobalCacheTimer;
                } else {
                    $CacheTimer = $OIDCacheTimer;
                }
            } else {
                $CacheTimer = $GlobalCacheTimer;
            }

            if ($CacheTimer > 0) {
                if (-r "$CacheDir/$OID") {
                    my @FileProperties=stat("$CacheDir/$OID");

                    # $FileProperties[9] = LastModifyTime of file
                    # only read the cache file if it is not too old
                    if (time - $CacheTimer < $FileProperties[9]) {
                        open (IN,"<$CacheDir/$OID");
                            $SnmpValue = <IN>;
                        close (IN);
                    }
                }
            }
            unless (defined $SnmpValue) {$SnmpValue = "";}
            # snmp value not from cache - read it from the net
            if ("X$SnmpValue" eq "X") {
                # get the snmp value - we do not check errors
                # here because of negative caching
                my $refhValue = $refoSession->get_request(-varbindlist => ["$OID"]);
                if (defined $refhValue->{"$OID"}) {
                    $SnmpValue  =   $refhValue->{"$OID"};
                    
                    # remove non ascii chars incl. \r and \n
                    $SnmpValue  =~  s/[\000-\037]|[\177-\377]//g;

                    # replace ; with , - just to be sure
                    $SnmpValue  =~  s/;/,/g;

                    if ($CacheTimer > 0) {

                        umask "0000";
                        open (OUT,">$CacheDir/$OID");
                            print OUT $SnmpValue;
                        close (OUT);
                    }
                }
                logger(2, "SnmpGet data from net:  OID=${OID}, value=${SnmpValue}, cache=${CacheTimer}s");
            } else {
                logger(2, "SnmpGet data from file: ${CacheDir}/${OID}, value=${SnmpValue}, cache=${CacheTimer}s");
            }
            # check result validity
            if ($SnmpValue =~ /noSuchObject/) {
                if ($strict == 0) {
                    # Replacing noSuchObject by an empty string.
                    # Indeed, the different snmp versions handle requests for missing oids 
                    # differently. v1 always returns an empty string. v2c/v3 return "noSuchObject" 
                    # string, and -translate noSuchObject -> '' correct that. BUt we do the change 
                    # to empty string after to be able to inform the user. Also, snmpwalk and other 
                    # unix programs don't have such a translate option.
                    # Ex: snmpwalk
                    # [icinga@server libexec]$ snmpwalk -Oqn -v 1 -t 15 -c s2un2um2up2u rt5.noc.cdt.europa.eu:161 .1.3.6.1.4.1.9.5.1.2.16.0
                    # [icinga@server libexec]$
                    # [icinga@server libexec]$ snmpwalk -Oqn -v 2c -t 15 -c s2un2um2up2u rt5.noc.cdt.europa.eu:161 .1.3.6.1.4.1.9.5.1.2.16.0
                    # .1.3.6.1.4.1.9.5.1.2.16.0 No Such Object available on this agent at this OID
                    # [icinga@server libexec]$
                    $SnmpValue = "";
                    logger(2, "SnmpGet data validity check: OID=${OID}, no such objet in the mib. Strict mode disabled, replacing by ''");
                } else {
                    logger(2, "SnmpGet data validity check: OID=${OID}, no such objet in the mib. Strict mode enabled, keeping 'noSuchObject'");
                }
            }
            # fill hash with data
            $refhSnmpValues->{$OID}="$SnmpValue";
        }
        
        # if we have only 1 OID -> return the Value instead the hash
        if ($#$refaOIDs == 0) {
            return $SnmpValue;
        }
    }
    # return the complete hash with OIDs as keys or
    # undef if the SNMP session fails
    return $refhSnmpValues;
}

# ------------------------------------------------------------------------

sub GetDataWithSnmp {

    ################################
	# SUB use: Get Data with perl net-snmp module
    # SUB specs: 
    #  * arg 0: host
	#  * arg 1: hash of SNMP options
    #  * arg 2: OID
    #  * arg 3: Directory for cached data    
    #  * arg 4: Cache timer
	#  * return: value retrieved by snmp
    ################################

    my $host        = shift;
    my $refhSNMPOptions = shift;
    my $refaOID     = shift;    # ref to array of OIDs (numbers only)
    my $CacheDir    = shift;
    my $CacheTimer  = shift;
    unless ($CacheTimer) {$CacheTimer = 0;}
    my $Value = "";
    
    if ( $refhSNMPOptions->{'version'} eq 3 ) {
        if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
            $Value = SnmpGet ({
                -hostname       => "$host",
                -port           => "$refhSNMPOptions->{'port'}",
                -version        => 3,
                -username		=> "$refhSNMPOptions->{'login'}",
                -authpassword	=> "$refhSNMPOptions->{'passwd'}",
                -authprotocol	=> "$refhSNMPOptions->{'authproto'}",
                -privpassword	=> "$refhSNMPOptions->{'privpass'}",
                -privprotocol   => "$refhSNMPOptions->{'privproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
                OID         => $refaOID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching  
            });
        } else {
            $Value = SnmpGet ({
                -hostname       => "$host",
                -port           => "$refhSNMPOptions->{'port'}",
                -version        => 3,
                -username		=> "$refhSNMPOptions->{'login'}",
                -authpassword	=> "$refhSNMPOptions->{'passwd'}",
                -authprotocol	=> "$refhSNMPOptions->{'authproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
                OID         => $refaOID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching  
            });
        }
    } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
        $Value = SnmpGet ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -version    => 2,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching  
        });
    } else {
        $Value = SnmpGet ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -version    => 1,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching  
        });
    }

    return ($Value);

}

# ------------------------------------------------------------------------

sub GetMultipleDataWithSnmp {

    ################################
	# SUB use: Get multiple Data with perl net-snmp module
    # SUB specs: 
    #  * arg 0: host
	#  * arg 1: hash of SNMP options
    #  * arg 2: OID
    #  * arg 3: Directory for cached data    
    #  * arg 4: Cache timer
	#  * return: hash of values retrieved by snmp
    ################################

    my $host        = shift;
    my $refhSNMPOptions = shift;
    my $refaOID     = shift;    # ref to array of OIDs (numbers only)
    my $CacheDir    = shift;
    my $CacheTimer  = shift;
    unless ($CacheTimer) {$CacheTimer = 0;}
    my $refhSNMP    = ();
    
    if ( $refhSNMPOptions->{'version'} eq 3 ) {
        if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
            $refhSNMP = SnmpGet ({
                -hostname   => "$host",
                -port       => "$refhSNMPOptions->{'port'}",
                -version    => 3,
                -username		=> "$refhSNMPOptions->{'login'}",
                -authpassword	=> "$refhSNMPOptions->{'passwd'}",
                -authprotocol	=> "$refhSNMPOptions->{'authproto'}",
                -privpassword	=> "$refhSNMPOptions->{'privpass'}",
                -privprotocol   => "$refhSNMPOptions->{'privproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                OID         => $refaOID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching
            });
        } else {
            $refhSNMP = SnmpGet ({
                -hostname   => "$host",
                -port       => "$refhSNMPOptions->{'port'}",
                -version    => 3,
                -username		=> "$refhSNMPOptions->{'login'}",
                -authpassword	=> "$refhSNMPOptions->{'passwd'}",
                -authprotocol	=> "$refhSNMPOptions->{'authproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                OID         => $refaOID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching
            });
        }
    } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
        $refhSNMP = SnmpGet ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -version    => 2,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching
        });
    } else {
        $refhSNMP = SnmpGet ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -version    => 1,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching
        });
    }
    
    return ($refhSNMP);
}

# ------------------------------------------------------------------------

sub GetDataWithUnixSnmpWalk {

    ################################
	# SUB use: Get Data with the unix snmpwalk command - this is faster 
	#          than perls snmp implementation
    # SUB specs: 
    #  * arg 0: host
	#  * arg 1: hash of SNMP options
    #  * arg 2: OID
    #  * arg 3: Directory for cached data    
    #  * arg 4: Cache timer
	#  * return: hash of values retrieved by snmp
    ################################

    my $host            = shift;
    my $refhSNMPOptions = shift;
    my $OID             = shift;    # only one OID (number or name)
    my $CacheDir        = shift;
    my $CacheTimer      = shift;
    unless ($CacheTimer) {$CacheTimer = 0;}
    my $strict          = 0;
    my $refaLinesTmp    = ();
    my $refaLines       = ();
    
    if ( $refhSNMPOptions->{'version'} eq 3 ) {
        if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
            ($refaLinesTmp) = ExecuteCommand ({
                Command     => "snmpbulkwalk -Oqn -v 3 -t $refhSNMPOptions->{'timeout'} -u $refhSNMPOptions->{'login'} -l authPriv -a $refhSNMPOptions->{'authproto'} -A $refhSNMPOptions->{'passwd'} -X $refhSNMPOptions->{'privpass'} -x $refhSNMPOptions->{'privproto'} ${host}:$refhSNMPOptions->{'port'} $OID",
                Retry       => 2,
                CacheDir    => $CacheDir,
                CacheTimer  => int rand ($CacheTimer),
            });
        } else {
            ($refaLinesTmp) = ExecuteCommand ({
                Command     => "snmpbulkwalk -Oqn -v 3 -t $refhSNMPOptions->{'timeout'} -u $refhSNMPOptions->{'login'} -l authNoPriv -a $refhSNMPOptions->{'authproto'} -A $refhSNMPOptions->{'passwd'} ${host}:$refhSNMPOptions->{'port'} $OID",
                Retry       => 2,
                CacheDir    => $CacheDir,
                CacheTimer  => int rand ($CacheTimer),
            });
        }
    } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
        ($refaLinesTmp) = ExecuteCommand ({
            Command     => "snmpbulkwalk -Oqn -v 2c -t $refhSNMPOptions->{'timeout'} -c $refhSNMPOptions->{'community'} ${host}:$refhSNMPOptions->{'port'} $OID",
            Retry       => 2,
            CacheDir    => $CacheDir,
            CacheTimer  => int rand ($CacheTimer),
        });
    } else {
        ($refaLinesTmp) = ExecuteCommand ({
            Command     => "snmpwalk -Oqn -v 1 -t $refhSNMPOptions->{'timeout'} -c $refhSNMPOptions->{'community'} ${host}:$refhSNMPOptions->{'port'} $OID",
            Retry       => 2,
            CacheDir    => $CacheDir,
            CacheTimer  => int rand ($CacheTimer),
        });
    }
    
    # check result validity
    foreach my $line ( @$refaLinesTmp ) {
        if ($line =~ /No Such Object available on this agent at this OID/) {
            if ($strict == 0) {
                # Replacing noSuchObject by an empty string.
                # Indeed, the different snmp versions handle requests for missing oids 
                # differently. While v1 returns an empty string, v2c/v3 return "noSuchObject" 
                # string
                # Ex: snmpwalk
                # [icinga@server libexec]$ snmpwalk -Oqn -v 1 -t 15 -c s2un2um2up2u rt5.noc.cdt.europa.eu:161 .1.3.6.1.4.1.9.5.1.2.16.0
                # [icinga@server libexec]$
                # [icinga@server libexec]$ snmpwalk -Oqn -v 2c -t 15 -c s2un2um2up2u rt5.noc.cdt.europa.eu:161 .1.3.6.1.4.1.9.5.1.2.16.0
                # .1.3.6.1.4.1.9.5.1.2.16.0 No Such Object available on this agent at this OID
                # [icinga@server libexec]$
                push(@$refaLines, "");
                logger(2, "SnmpGet data validity check: $line, no such objet in the mib. Strict mode disabled, replacing by ''");
            } else {
                push(@$refaLines, $line);
                logger(2, "SnmpGet data validity check: $line, no such objet in the mib. Strict mode enabled, keeping '$line'");
            }
        } else {
            push(@$refaLines, $line);
        }
    }
    
    print Dumper($refaLines);

    return $refaLines;
}

# ------------------------------------------------------------------------
# ExecuteCommand Routine. Enhanced with our cache algorith...

sub ExecuteCommand {
    my $refhStruct      = shift;
    my $Command         = $refhStruct->{Command};
    my $GlobalCacheDir  = $refhStruct->{CacheDir};

    my $refaLines=[];   # Pointer to Array of strings (output)

    my $CacheFile;      # Filename storing cached data
    my $ExitCode;       # exit code of the unix command

    my $Now=time();     # current time in seconds since epoch

    my $CacheDir="$GlobalCacheDir/ExecuteCommand/"; # cache dir

    # Create Cachedir if not existend
    not -d $CacheDir and MyMkdir($CacheDir);

    # If caching for this command is enabled
    if ($refhStruct->{CacheTimer} > 0) {

        $CacheFile = $CacheDir . normalize ("$Command");

        if (-r "$CacheFile") {
            my @FileProperties=stat($CacheFile);

            # $FileProperties[9] = LastModifyTime of file
            # only read the cache file if it is not too old
            if ($Now-$refhStruct->{CacheTimer} < $FileProperties[9]) {
                open (IN,"<$CacheFile");
                    @$refaLines=<IN>;
                close (IN);
                # leave this subroutine with cached data found
                logger(3, "ExecuteCommand: got data from cache $CacheFile");
                return ($refaLines,0);
            }
        }
    }

    # execute the unix command
    open(UNIX,"$Command |") or last;
        while (<UNIX>) {
            push @$refaLines,$_;
        }
    close(UNIX);
    $ExitCode=$? >> 8; # calculate the exit code


    logger(3, "ExecuteCommand: executed \"$Command\" and got ExitCode \"$ExitCode\"");

    # stop in case of error
    if ($ExitCode != 0) {
        logger(0, "The UNIX command \"$Command\" returned the ExitCode \"$ExitCode\"");
        exit 1;
    }
    
    # write a cache file if the cache timer > 0
    if ($refhStruct->{CacheTimer} > 0) {
        logger(3, "ExecuteCommand: write cache file CacheTimer=$refhStruct->{CacheTimer}");
        umask "0000"; # change to rw-rw-rw maybe changed later because of security
        open (OUT,">$CacheFile") or return ($refaLines,$ExitCode);
            print OUT @$refaLines;
        close (OUT);
    }
    return ($refaLines,$ExitCode);
}

1;

__END__
