##############################################################################
# "SnmpUtils" library
# A collection of shared functions related to snmp.
#
# Version 0.1
# Written by Y. Charton, from extracts of check_interface_table release 1-3
#
# Revision history:
# 2011-06-08 v0.1   Y. Charton    First release
# 2012-04-02 v0.2   Y. Charton    Added transport domain selection 
#                                 (idea from Bjorn Frostberg)
#
##############################################################################

package SnmpUtils;
use strict;
use lib ('@libdir@');
use Exporter;
use GeneralUtils;

##############################################################################
### I N I T ##################################################################
##############################################################################

BEGIN {
    use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION $AUTHOR);
    @ISA         = qw(Exporter);
    @EXPORT      = qw(SnmpGet GetDataWithSnmp GetMultipleDataWithSnmp SnmpGetTable GetTableDataWithSnmp GetDataWithUnixSnmpWalk ExecuteCommand);
    @EXPORT_OK   = qw();
    $VERSION     = 0.2;
    $AUTHOR      = "Y. Charton";
}

##############################################################################
### S U B S ##################################################################
##############################################################################

#============================================================================#
# Single / one by one OID request via perl's netsnmp
#----------------------------------------------------------------------------#
# SnmpGet 
# GetDataWithSnmp 
# GetMultipleDataWithSnmp
#----------------------------------------------------------------------------#

sub SnmpGet {

    ################################
    # SUB use: 
    # SUB specs: 
    #  * arg 0:
    #  * return:
    ################################

    my $refhStruct = shift;

    #
    # store variables and delete them from the hash
    # this is necessary for the snmp session which takes the same
    # hash ref and does not work with arguments other than starting
    # with a dash
    #

    my $refaOIDs            = $refhStruct->{OID}; # ref to array of OIDs
    my $GlobalCacheDir      = $refhStruct->{CacheDir};
    my $GlobalCacheTimer    = $refhStruct->{CacheTimer};
    my $strict              = 0;
    
    delete $refhStruct->{OID};
    delete $refhStruct->{CacheDir};
    delete $refhStruct->{CacheTimer};

    my $refhSnmpValues; # hash returned to the caller
    my $refoSession;    # SNMP session object
    my $SessionError;   # SNMP session error
    
    # example cache dir name
    # /tmp/watchit/Cache/SnmpGet/cat-itd-01
    my $CacheDir = "$GlobalCacheDir/SnmpGet";

    # Create the directory if not existend
    not -d $CacheDir and MyMkdir($CacheDir);

    # create snmp session
    ($refoSession,$SessionError) = Net::SNMP->session (%$refhStruct);
    
    # check if any session establishment problem
    if (!defined $refoSession) {
      logger(0, "SNMP session establishment problem: ".$SessionError);
    }
    
    my $OIDLine;    # one line of OIDs or OIDs and caching timers
    my $SnmpValue;  # one snmp value

    if (defined $refoSession) {

        # OIDs come in an array (ref) - go through each
        # example:
        #    $refaOIDs = [
        #              '.1.3.6.1.2.1.2.2.1.11.1',
        #              '.1.3.6.1.2.1.2.2.1.12.1'
        #            ];
        for $OIDLine (@$refaOIDs) {

            my  $CacheTimer=0;

            $SnmpValue="";  # clear value

            # OID could be .1.3.6.1.2.1.2.2.1.11.1,200
            # <OID>,<CacheTimer> for this OID only
            my ($OID,$OIDCacheTimer) = ("","");
            ($OID,$OIDCacheTimer) = split ',',$OIDLine,2;

            if (defined $OIDCacheTimer) {
                # remove non digits
                $OIDCacheTimer =~ s/\D//g;
                if ("X$OIDCacheTimer" eq "X") { # is empty?
                    $CacheTimer = $GlobalCacheTimer;
                } else {
                    $CacheTimer = $OIDCacheTimer;
                }
            } else {
                $CacheTimer = $GlobalCacheTimer;
            }

            if ($CacheTimer > 0) {
                if (-r "$CacheDir/$OID") {
                    my @FileProperties=stat("$CacheDir/$OID");

                    # $FileProperties[9] = LastModifyTime of file
                    # only read the cache file if it is not too old
                    if (time - $CacheTimer < $FileProperties[9]) {
                        open (IN,"<$CacheDir/$OID");
                            $SnmpValue = <IN>;
                        close (IN);
                    }
                }
            }
            unless (defined $SnmpValue) {$SnmpValue = "";}
            # snmp value not from cache - read it from the net
            if ("X$SnmpValue" eq "X") {
                # get the snmp value - we do not check errors
                # here because of negative caching
                my $refhValue = $refoSession->get_request(-varbindlist => ["$OID"]);
                if (defined $refhValue->{"$OID"}) {
                    $SnmpValue  =   $refhValue->{"$OID"};
                    
                    # remove non ascii chars incl. \r and \n
                    $SnmpValue  =~  s/[\000-\037]|[\177-\377]//g;

                    # replace ; with , - just to be sure
                    $SnmpValue  =~  s/;/,/g;

                    if ($CacheTimer > 0) {

                        umask "0000";
                        open (OUT,">$CacheDir/$OID");
                            print OUT $SnmpValue;
                        close (OUT);
                    }
                }
                logger(3, "SnmpGet data from net:  OID=${OID}, value=${SnmpValue}, cache=${CacheTimer}s");
            } else {
                logger(3, "SnmpGet data from file: ${CacheDir}/${OID}, value=${SnmpValue}, cache=${CacheTimer}s");
            }
            # check result validity
            if ($SnmpValue =~ /noSuchObject/) {
                if ($strict == 0) {
                    # Replacing noSuchObject by an empty string.
                    # Indeed, the different snmp versions handle requests for missing oids 
                    # differently. v1 always returns an empty string. v2c/v3 return "noSuchObject" 
                    # string, and -translate noSuchObject -> '' correct that. BUt we do the change 
                    # to empty string after to be able to inform the user. Also, snmpwalk and other 
                    # unix programs don't have such a translate option.
                    # Ex: snmpwalk
                    # [icinga@server libexec]$ snmpwalk -Oqn -v 1 -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
                    # [icinga@server libexec]$
                    # [icinga@server libexec]$ snmpwalk -Oqn -v 2c -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
                    # .1.3.6.1.4.1.9.5.1.2.16.0 No Such Object available on this agent at this OID
                    # [icinga@server libexec]$
                    $SnmpValue = "";
                    logger(3, "SnmpGet data validity check: OID=${OID}, no such objet in the mib. Strict mode disabled, replacing by ''");
                } else {
                    logger(3, "SnmpGet data validity check: OID=${OID}, no such objet in the mib. Strict mode enabled, keeping 'noSuchObject'");
                }
            }
            if ($SnmpValue =~ /noSuchInstance/) {
                if ($strict == 0) {
                    # Replacing noSuchInstance by an empty string.
                    # Indeed, the different snmp versions handle requests for missing oids 
                    # differently. v1 always returns an empty string. v2c/v3 return "noSuchInstance" 
                    $SnmpValue = "";
                    logger(3, "SnmpGet data validity check: OID=${OID}, no such objet in the mib. Strict mode disabled, replacing by ''");
                } else {
                    logger(3, "SnmpGet data validity check: OID=${OID}, no such objet in the mib. Strict mode enabled, keeping 'noSuchInstance'");
                }
            }
            # fill hash with data
            $refhSnmpValues->{$OID}="$SnmpValue";
        }
        
        # if we have only 1 OID -> return the Value instead the hash
        if ($#$refaOIDs == 0) {
            return $SnmpValue;
        }
    }
    # return the complete hash with OIDs as keys or
    # undef if the SNMP session fails
    return $refhSnmpValues;
}

# ------------------------------------------------------------------------

sub GetDataWithSnmp {

    ################################
	# SUB use: Get Data with perl net-snmp module
    # SUB specs: 
    #  * arg 0: host
	#  * arg 1: hash of SNMP options
    #  * arg 2: OID
    #  * arg 3: Directory for cached data    
    #  * arg 4: Cache timer
	#  * return: value retrieved by snmp
    ################################

    my $host        = shift;
    my $refhSNMPOptions = shift;
    my $refaOID     = shift;    # ref to array of OIDs (numbers only)
    my $CacheDir    = shift;
    my $CacheTimer  = shift;
    unless ($CacheTimer) {$CacheTimer = 0;}
    my $Value = "";
    
    if ( $refhSNMPOptions->{'version'} eq 3 ) {
        if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
            $Value = SnmpGet ({
                -hostname       => "$host",
                -port           => "$refhSNMPOptions->{'port'}",
                -domain         => "$refhSNMPOptions->{'domain'}",
                -version        => 3,
                -username		=> "$refhSNMPOptions->{'login'}",
                -authpassword	=> "$refhSNMPOptions->{'passwd'}",
                -authprotocol	=> "$refhSNMPOptions->{'authproto'}",
                -privpassword	=> "$refhSNMPOptions->{'privpass'}",
                -privprotocol   => "$refhSNMPOptions->{'privproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
                OID         => $refaOID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching  
            });
        } else {
            $Value = SnmpGet ({
                -hostname       => "$host",
                -port           => "$refhSNMPOptions->{'port'}",
                -domain         => "$refhSNMPOptions->{'domain'}",
                -version        => 3,
                -username		=> "$refhSNMPOptions->{'login'}",
                -authpassword	=> "$refhSNMPOptions->{'passwd'}",
                -authprotocol	=> "$refhSNMPOptions->{'authproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
                OID         => $refaOID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching  
            });
        }
    } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
        $Value = SnmpGet ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -domain     => "$refhSNMPOptions->{'domain'}",
            -version    => 2,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching  
        });
    } else {
        $Value = SnmpGet ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -domain     => "$refhSNMPOptions->{'domain'}",
            -version    => 1,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching  
        });
    }

    return ($Value);

}

# ------------------------------------------------------------------------

sub GetMultipleDataWithSnmp {

    ################################
	# SUB use: Get multiple Data with perl net-snmp module
    # SUB specs: 
    #  * arg 0: host
	#  * arg 1: hash of SNMP options
    #  * arg 2: OID
    #  * arg 3: Directory for cached data    
    #  * arg 4: Cache timer
	#  * return: hash of values retrieved by snmp
    ################################

    my $host        = shift;
    my $refhSNMPOptions = shift;
    my $refaOID     = shift;    # ref to array of OIDs (numbers only)
    my $CacheDir    = shift;
    my $CacheTimer  = shift;
    unless ($CacheTimer) {$CacheTimer = 0;}
    my $refhSNMP    = ();
    
    if ( $refhSNMPOptions->{'version'} eq 3 ) {
        if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
            $refhSNMP = SnmpGet ({
                -hostname   => "$host",
                -port       => "$refhSNMPOptions->{'port'}",
                -domain     => "$refhSNMPOptions->{'domain'}",
                -version    => 3,
                -username		=> "$refhSNMPOptions->{'login'}",
                -authpassword	=> "$refhSNMPOptions->{'passwd'}",
                -authprotocol	=> "$refhSNMPOptions->{'authproto'}",
                -privpassword	=> "$refhSNMPOptions->{'privpass'}",
                -privprotocol   => "$refhSNMPOptions->{'privproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                OID         => $refaOID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching
            });
        } else {
            $refhSNMP = SnmpGet ({
                -hostname   => "$host",
                -port       => "$refhSNMPOptions->{'port'}",
                -domain     => "$refhSNMPOptions->{'domain'}",
                -version    => 3,
                -username		=> "$refhSNMPOptions->{'login'}",
                -authpassword	=> "$refhSNMPOptions->{'passwd'}",
                -authprotocol	=> "$refhSNMPOptions->{'authproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                OID         => $refaOID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching
            });
        }
    } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
        $refhSNMP = SnmpGet ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -domain     => "$refhSNMPOptions->{'domain'}",
            -version    => 2,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching
        });
    } else {
        $refhSNMP = SnmpGet ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -domain     => "$refhSNMPOptions->{'domain'}",
            -version    => 1,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching
        });
    }
    
    return ($refhSNMP);
}

#============================================================================#
# Table OID request via perl's netsnmp
#----------------------------------------------------------------------------#
# SnmpGetTable 
#  
#----------------------------------------------------------------------------#

sub SnmpGetTable {

    ################################
    # SUB use: 
    # SUB specs: 
    #  * arg 0:
    #  * return:
    ################################

    my $refhStruct = shift;

    #
    # store variables and delete them from the hash
    # this is necessary for the snmp session which takes the same
    # hash ref and does not work with arguments other than starting
    # with a dash
    #

    my $OIDLine             = $refhStruct->{OID};
    my $GlobalCacheDir      = $refhStruct->{CacheDir};
    my $GlobalCacheTimer    = $refhStruct->{CacheTimer};
    my $strict              = 0;
    
    delete $refhStruct->{OID};
    delete $refhStruct->{CacheDir};
    delete $refhStruct->{CacheTimer};

    my $refhSnmpValues; # hash returned to the caller
    my $refoSession;    # SNMP session object
    my $SessionError;   # SNMP session error

    my $refaLines=[];   # Pointer to Array of strings (output)
    
    # example cache dir name
    # /tmp/watchit/Cache/SnmpGet/cat-itd-01
    my $CacheDir = "$GlobalCacheDir/SnmpGetTable";

    # Create the directory if not existend
    not -d $CacheDir and MyMkdir($CacheDir);

    # create snmp session
    ($refoSession,$SessionError) = Net::SNMP->session (%$refhStruct);
    
    # check if any session establishment problem
    if (!defined $refoSession) {
      logger(0, "SNMP session establishment problem: ".$SessionError);
    }
    
    if (defined $refoSession) {

        # OIDs come in an array (ref) - go through each
        # example:
        #    $refaOIDs = [
        #              '.1.3.6.1.2.1.2.2.1.11.1',
        #              '.1.3.6.1.2.1.2.2.1.12.1'
        #            ];
        
        my  $CacheTimer=0;

        # OID could be .1.3.6.1.2.1.2.2.1.11.1,200
        # <OID>,<CacheTimer> for this OID only
        my ($OID,$OIDCacheTimer) = ("","");
        ($OID,$OIDCacheTimer) = split ',',$OIDLine,2;

        if (defined $OIDCacheTimer) {
            # remove non digits
            $OIDCacheTimer =~ s/\D//g;
            if ("X$OIDCacheTimer" eq "X") { # is empty?
                $CacheTimer = $GlobalCacheTimer;
            } else {
                $CacheTimer = $OIDCacheTimer;
            }
        } else {
            $CacheTimer = $GlobalCacheTimer;
        }

        my $readFromCache = 0;
        if ($CacheTimer > 0) {
            if (-r "$CacheDir/$OID") {
                my @FileProperties=stat("$CacheDir/$OID");

                # $FileProperties[9] = LastModifyTime of file
                # only read the cache file if it is not too old
                if (time - $CacheTimer < $FileProperties[9]) {
                    open (IN,"<$CacheDir/$OID");
                        @$refaLines = <IN>;
                    close (IN);
                    # leave this subroutine with cached data found
                    logger(3, "SnmpGetTable: got data from cache $CacheDir/$OID");
                    $readFromCache = 1;
                }
                
            }
        }
        # snmp value not from cache - read it from the net
        if ($readFromCache == 0) {
            my $refhValues = $refoSession->get_table(-baseoid => "$OID");
            foreach my $k (keys(%{$refhValues})) {
                logger(3, "OID=$k, Value=$refhValues->{$k}");
                my $SnmpValue = $refhValues->{$k};
                
                # remove non ascii chars incl. \r and \n
                $SnmpValue  =~  s/[\000-\037]|[\177-\377]//g;
                
                # replace ; with , - just to be sure
                $SnmpValue  =~  s/;/,/g;
                
                # check result validity
                if ($SnmpValue =~ /noSuchObject/) {
                    if ($strict == 0) {
                        # Replacing noSuchObject by an empty string.
                        # Indeed, the different snmp versions handle requests for missing oids 
                        # differently. v1 always returns an empty string. v2c/v3 return "noSuchObject" 
                        # string, and -translate noSuchObject -> '' correct that. BUt we do the change 
                        # to empty string after to be able to inform the user. Also, snmpwalk and other 
                        # unix programs don't have such a translate option.
                        # Ex: snmpwalk
                        # [icinga@server libexec]$ snmpwalk -Oqn -v 1 -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
                        # [icinga@server libexec]$
                        # [icinga@server libexec]$ snmpwalk -Oqn -v 2c -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
                        # .1.3.6.1.4.1.9.5.1.2.16.0 No Such Object available on this agent at this OID
                        # [icinga@server libexec]$
                        $SnmpValue = "";
                        logger(3, "SnmpGetTable data validity check: OID=${OID}, no such objet in the mib. Strict mode disabled, replacing by ''");
                    } else {
                        logger(3, "SnmpGetTable data validity check: OID=${OID}, no such objet in the mib. Strict mode enabled, keeping 'noSuchObject'");
                    }
                }
                if ($SnmpValue =~ /noSuchInstance/) {
                    if ($strict == 0) {
                        # Replacing noSuchInstance by an empty string.
                        # Indeed, the different snmp versions handle requests for missing oids 
                        # differently. v1 always returns an empty string. v2c/v3 return "noSuchInstance" 
                        $SnmpValue = "";
                        logger(3, "SnmpGetTable data validity check: OID=${OID}, no such objet in the mib. Strict mode disabled, replacing by ''");
                    } else {
                        logger(3, "SnmpGetTable data validity check: OID=${OID}, no such objet in the mib. Strict mode enabled, keeping 'noSuchInstance'");
                    }
                }
                
                # fill result array with data
                push @$refaLines,"$k $SnmpValue";
            }
            # write a cache file if the cache timer > 0
            if ($CacheTimer > 0) {
                logger(3, "SnmpGetTable: write cache file $CacheDir/$OID, CacheTimer=$CacheTimer");
                umask "0000"; # change to rw-rw-rw maybe changed later because of security
                open (OUT,">$CacheDir/$OID");
                foreach my $line (@$refaLines) {
                        print OUT "$line\n";
                }
                close (OUT);
            }
            logger(3, "SnmpGetTable data from net:  OID=${OID}, cache=${CacheTimer}s");
        } else {
            logger(3, "SnmpGetTable data from file: ${CacheDir}/${OID}, cache=${CacheTimer}s");
        }

    }
    return $refaLines;
}

#----------------------------------------------------------------------------#

sub GetTableDataWithSnmp {

    ################################
	# SUB use: Get multiple Data with perl net-snmp module
    # SUB specs: 
    #  * arg 0: host
	#  * arg 1: hash of SNMP options
    #  * arg 2: OID
    #  * arg 3: Directory for cached data    
    #  * arg 4: Cache timer
	#  * return: hash of values retrieved by snmp
    ################################

    my $host        = shift;
    my $refhSNMPOptions = shift;
    my $OID             = shift;    # only one OID (number or name)
    my $CacheDir    = shift;
    my $CacheTimer  = shift;
    unless ($CacheTimer) {$CacheTimer = 0;}
    my $strict          = 0;
    my $refaLines       = ();
    
    if ( $refhSNMPOptions->{'version'} eq 3 ) {
        if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
            ($refaLines) = SnmpGetTable ({
                -hostname   => "$host",
                -port       => "$refhSNMPOptions->{'port'}",
                -domain     => "$refhSNMPOptions->{'domain'}",
                -version    => 3,
                -username		=> "$refhSNMPOptions->{'login'}",
                -authpassword	=> "$refhSNMPOptions->{'passwd'}",
                -authprotocol	=> "$refhSNMPOptions->{'authproto'}",
                -privpassword	=> "$refhSNMPOptions->{'privpass'}",
                -privprotocol   => "$refhSNMPOptions->{'privproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                OID         => $OID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching
            });
        } else {
            ($refaLines) = SnmpGetTable ({
                -hostname   => "$host",
                -port       => "$refhSNMPOptions->{'port'}",
                -domain     => "$refhSNMPOptions->{'domain'}",
                -version    => 3,
                -username		=> "$refhSNMPOptions->{'login'}",
                -authpassword	=> "$refhSNMPOptions->{'passwd'}",
                -authprotocol	=> "$refhSNMPOptions->{'authproto'}",
                -timeout        => "$refhSNMPOptions->{'timeout'}",
                OID         => $OID,
                CacheDir    => "$CacheDir",
                CacheTimer  => int rand ($CacheTimer),  # random caching
            });
        }
    } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
        ($refaLines) = SnmpGetTable ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -domain     => "$refhSNMPOptions->{'domain'}",
            -version    => 2,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            OID         => $OID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching
        });
    } else {
        ($refaLines) = SnmpGetTable ({
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -domain     => "$refhSNMPOptions->{'domain'}",
            -version    => 1,
            -community  => "$refhSNMPOptions->{'community'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            OID         => $OID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching
        });
    }
    
    return $refaLines;
}

#============================================================================#
# Table OID request via UNIX snmpwalk / snmpbulkwalk
#----------------------------------------------------------------------------#
# GetDataWithUnixSnmpWalk 
# ExecuteCommand 
#----------------------------------------------------------------------------#

sub GetDataWithUnixSnmpWalk {

    ################################
	# SUB use: Get Data with the unix snmpwalk command - this is faster 
	#          than perls snmp implementation
    # SUB specs: 
    #  * arg 0: host
	#  * arg 1: hash of SNMP options
    #  * arg 2: OID
    #  * arg 3: Directory for cached data    
    #  * arg 4: Cache timer
	#  * return: hash of values retrieved by snmp
    ################################

    my $host            = shift;
    my $refhSNMPOptions = shift;
    my $OID             = shift;    # only one OID (number or name)
    my $CacheDir        = shift;
    my $CacheTimer      = shift;
    unless ($CacheTimer) {$CacheTimer = 0;}
    my $strict          = 0;
    my $refaLinesTmp    = ();
    my $refaLines       = ();
    
    if ( $refhSNMPOptions->{'version'} eq 3 ) {
        if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
            ($refaLinesTmp) = ExecuteCommand ({
                Command     => "snmpbulkwalk -Oqn -v 3 -t $refhSNMPOptions->{'timeout'} -u $refhSNMPOptions->{'login'} -l authPriv -a $refhSNMPOptions->{'authproto'} -A $refhSNMPOptions->{'passwd'} -X $refhSNMPOptions->{'privpass'} -x $refhSNMPOptions->{'privproto'} $refhSNMPOptions->{'domain'}:${host}:$refhSNMPOptions->{'port'} $OID",
                Retry       => 2,
                CacheDir    => $CacheDir,
                CacheTimer  => int rand ($CacheTimer),
            });
        } else {
            ($refaLinesTmp) = ExecuteCommand ({
                Command     => "snmpbulkwalk -Oqn -v 3 -t $refhSNMPOptions->{'timeout'} -u $refhSNMPOptions->{'login'} -l authNoPriv -a $refhSNMPOptions->{'authproto'} -A $refhSNMPOptions->{'passwd'} $refhSNMPOptions->{'domain'}:${host}:$refhSNMPOptions->{'port'} $OID",
                Retry       => 2,
                CacheDir    => $CacheDir,
                CacheTimer  => int rand ($CacheTimer),
            });
        }
    } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
        ($refaLinesTmp) = ExecuteCommand ({
            Command     => "snmpbulkwalk -Oqn -v 2c -t $refhSNMPOptions->{'timeout'} -c $refhSNMPOptions->{'community'} $refhSNMPOptions->{'domain'}:${host}:$refhSNMPOptions->{'port'} $OID",
            Retry       => 2,
            CacheDir    => $CacheDir,
            CacheTimer  => int rand ($CacheTimer),
        });
    } else {
        ($refaLinesTmp) = ExecuteCommand ({
            Command     => "snmpwalk -Oqn -v 1 -t $refhSNMPOptions->{'timeout'} -c $refhSNMPOptions->{'community'} $refhSNMPOptions->{'domain'}:${host}:$refhSNMPOptions->{'port'} $OID",
            Retry       => 2,
            CacheDir    => $CacheDir,
            CacheTimer  => int rand ($CacheTimer),
        });
    }
    
    # check result validity
    foreach my $line ( @$refaLinesTmp ) {
        if ($line =~ /No Such Object available on this agent at this OID/) {
            if ($strict == 0) {
                # Replacing noSuchObject by an empty string.
                # Indeed, the different snmp versions handle requests for missing oids 
                # differently. While v1 returns an empty string, v2c/v3 return "noSuchObject" 
                # string
                # Ex: snmpwalk
                # [icinga@server libexec]$ snmpwalk -Oqn -v 1 -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
                # [icinga@server libexec]$
                # [icinga@server libexec]$ snmpwalk -Oqn -v 2c -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
                # .1.3.6.1.4.1.9.5.1.2.16.0 No Such Object available on this agent at this OID
                # [icinga@server libexec]$
                logger(3, "SnmpGet data validity check: $line, no such objet in the mib. Strict mode disabled, returning an empty array");
                return $refaLines;
            } else {
                push(@$refaLines, $line);
                logger(3, "SnmpGet data validity check: $line, no such objet in the mib. Strict mode enabled, keeping '$line'");
            }
        } else {
            push(@$refaLines, $line);
        }
    }

    return $refaLines;
}

# ------------------------------------------------------------------------
# ExecuteCommand Routine. Enhanced with our cache algorith...

sub ExecuteCommand {
    my $refhStruct      = shift;
    my $Command         = $refhStruct->{Command};
    my $GlobalCacheDir  = $refhStruct->{CacheDir};

    my $refaLines=[];   # Pointer to Array of strings (output)

    my $CacheFile;      # Filename storing cached data
    my $ExitCode;       # exit code of the unix command

    my $Now=time();     # current time in seconds since epoch

    my $CacheDir="$GlobalCacheDir/ExecuteCommand/"; # cache dir

    # Create Cachedir if not existend
    not -d $CacheDir and MyMkdir($CacheDir);

    # If caching for this command is enabled
    if ($refhStruct->{CacheTimer} > 0) {

        $CacheFile = $CacheDir . normalize ("$Command");

        if (-r "$CacheFile") {
            my @FileProperties=stat($CacheFile);

            # $FileProperties[9] = LastModifyTime of file
            # only read the cache file if it is not too old
            if ($Now-$refhStruct->{CacheTimer} < $FileProperties[9]) {
                open (IN,"<$CacheFile");
                    @$refaLines=<IN>;
                close (IN);
                # leave this subroutine with cached data found
                logger(3, "ExecuteCommand: got data from cache $CacheFile");
                return ($refaLines,0);
            }
        }
    }

    # execute the unix command
    open(UNIX,"$Command |") or last;
        while (<UNIX>) {
            push @$refaLines,$_;
        }
    close(UNIX);
    $ExitCode=$? >> 8; # calculate the exit code


    logger(3, "ExecuteCommand: executed \"$Command\" and got ExitCode \"$ExitCode\"");

    # stop in case of error
    if ($ExitCode != 0) {
        logger(0, "The UNIX command \"$Command\" returned the ExitCode \"$ExitCode\"");
        exit 1;
    }
    
    # write a cache file if the cache timer > 0
    if ($refhStruct->{CacheTimer} > 0) {
        logger(3, "ExecuteCommand: write cache file CacheTimer=$refhStruct->{CacheTimer}");
        umask "0000"; # change to rw-rw-rw maybe changed later because of security
        open (OUT,">$CacheFile") or return ($refaLines,$ExitCode);
            print OUT @$refaLines;
        close (OUT);
    }
    return ($refaLines,$ExitCode);
}

1;

__END__
