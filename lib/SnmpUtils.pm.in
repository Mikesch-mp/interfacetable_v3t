##############################################################################
# "SnmpUtils" library
# A collection of shared functions related to snmp.
#
# Version : 0.06
# Author  : Y. Charton
#
# Revision history:
# 2011-06-08 v0.01   Y. Charton    First release, based from extracts of 
#                                  check_interface_table 1-3 releases
# 2011-12-30 v0.02   Y. Charton    Fusion of the get table functions
# 2012-05-02 v0.03   Y. Charton    Added transport domain selection and max-repetitions
#                                  (idea by Bjorn Frostberg), fix problem where
#                                  empty snmp query result from cache was not used
#                                  and overwritten every time, better debug
# 2012-08-29 v0.04   Y. Charton    Not empty check on result array moved inside the snmp library
#                                  OID passed to snmp functions with related info (via a hash)
# 2012-11-07 v0.05   Y. Charton    Revamped some snmp query arguments method
#                                  Added contextname (snmp v3)
# 2012-11-10 v0.06   Y. Charton    Prevent double-quoted values in unixsnmp
#                                  Force non-translated values in unixsnmp
# 2013-01-02 v0.07   Y. Charton    Specific StandardizeSNMPOutputBehaviour function
#
##############################################################################

package SnmpUtils;
use strict;
use lib ('@libdir@');
use Data::Dumper;
  $Data::Dumper::Sortkeys = 1;
use Storable;
use Exporter;
use GeneralUtils;

##############################################################################
### I N I T ##################################################################
##############################################################################

BEGIN {
    use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION $AUTHOR);
    @ISA         = qw(Exporter);
    @EXPORT      = qw(SnmpGet GetDataWithSnmp SnmpGetTable GetTableDataWithSnmp ExecuteCommand StandardizeSNMPOutputBehaviour);
    @EXPORT_OK   = qw();
    $VERSION     = 0.07;
    $AUTHOR      = "Y. Charton";
}

##############################################################################
### S U B S ##################################################################
##############################################################################

#============================================================================#
# Single / one by one OID request via perl's netsnmp
#----------------------------------------------------------------------------#
# SnmpGet
# GetDataWithSnmp
#----------------------------------------------------------------------------#

sub SnmpGet {

    ################################
    # SUB use:
    # SUB specs:
    #  * arg 0:
    #  * return:
    ################################

    my $refhStruct = shift;

    # store variables and delete them from the hash
    # this is necessary for the snmp session which takes the same
    # hash ref and does not work with arguments other than starting
    # with a dash
    my $refaOIDs            = $refhStruct->{OID}; # ref to array of OIDs
    my $GlobalCacheDir      = $refhStruct->{CacheDir};
    my $GlobalCacheTimer    = $refhStruct->{CacheTimer};
    
    my $stdSNMPOutBehavior  = 1;

    delete $refhStruct->{OID};
    delete $refhStruct->{CacheDir};
    delete $refhStruct->{CacheTimer};

    my $refoSession;    # SNMP session object
    my $sessionError;   # SNMP session error

    my $refhQuery = ();
    if (defined $refhStruct->{'-contextname'}) {
        $refhQuery->{'-contextname'} = $refhStruct->{'-contextname'};
        delete $refhStruct->{'-contextname'};
    }

    my $refhErrorOutput;
    $refhErrorOutput->{code} = 0;
    $refhErrorOutput->{msg} = "";
    my $refhResultOutput;
    
    # example cache dir name
    my $CacheDir = "$GlobalCacheDir/SnmpGet";

    # Create the directory if not exist
    not -d $CacheDir and MyMkdir($CacheDir);

    # create snmp session object
    ($refoSession,$sessionError) = Net::SNMP->session (%$refhStruct);
    
    if (defined $refoSession) {

        my $OIDLine;    # one line of OIDs or OIDs and caching timers
                
        # OIDs come in an array (ref) - go through each
        # example:
        #    $refaOIDs = [
        #              '.1.3.6.1.2.1.2.2.1.11.1',
        #              '.1.3.6.1.2.1.2.2.1.12.1'
        #            ];
        for $OIDLine (@$refaOIDs) {

            my $refhSnmpResult=undef;
            my $CacheTimer=0;

            # OID could be .1.3.6.1.2.1.2.2.1.11.1,200
            # <OID>,<CacheTimer> for this OID only
            my ($OID,$OIDCacheTimer) = ("","");
            ($OID,$OIDCacheTimer) = split ',',$OIDLine,2;
            $refhQuery->{'-varbindlist'} = ["$OID"];
            
            if (defined $OIDCacheTimer) {
                # remove non digits
                $OIDCacheTimer =~ s/\D//g;
                if ("X$OIDCacheTimer" eq "X") { # is empty?
                    $CacheTimer = $GlobalCacheTimer;
                } else {
                    $CacheTimer = $OIDCacheTimer;
                }
            } else {
                $CacheTimer = $GlobalCacheTimer;
            }

            my $readFromCache = 0;
            if ($CacheTimer > 0) {
                if (-r "${CacheDir}/${OID}.dat") {
                    logger(3, "Cached data file found: ${CacheDir}/${OID}.dat, cacheTimer=${CacheTimer}s");
                    my @FileProperties=stat("${CacheDir}/${OID}.dat");

                    # $FileProperties[9] = LastModifyTime of file
                    # only read the cache file if it is not too old
                    if (time - $CacheTimer < $FileProperties[9]) {
                        logger(3, " valid cached data, loading");
                        $refhSnmpResult = retrieve("${CacheDir}/${OID}.dat");
                        die "Unable to retrieve from ${CacheDir}/${OID}.dat: $!\n" unless defined $refhSnmpResult;
                        # leave this subroutine with cached data found
                        $readFromCache = 1;
                    } else {
                        logger(3, " expired cached data, skipping");
                    }
                }
            }

            unless (defined $refhSnmpResult) {$refhSnmpResult = {};}
            # snmp value not from cache - read it from the net
            if ($readFromCache == 0) {
                $refhSnmpResult = $refoSession->get_request(%$refhQuery);
                if (defined $refhSnmpResult) {
                    logger(3, "Data collected from net: OID=${OID}, value='$refhSnmpResult->{\"$OID\"}', cacheTimer=${CacheTimer}s");
                    
                    # remove non ascii chars incl. \r and \n
                    $refhSnmpResult->{"$OID"} =~  s/[\000-\037]|[\177-\377]//g;
                    # replace ; with , - just to be sure
                    $refhSnmpResult->{"$OID"} =~  s/;/,/g;

                    if ($CacheTimer > 0) {
                        logger(3, "Write cache file ${CacheDir}/${OID}.dat, CacheTimer=$CacheTimer");
                        umask "0000"; # change to rw-rw-rw maybe changed later because of security
                        store ($refhSnmpResult, "${CacheDir}/${OID}.dat") or die "cannot store to ${CacheDir}/${OID}.dat: $!\n";
                    }
                } else {
                    logger(0, "SNMP problem: ".$refoSession->error());
                    $refhErrorOutput->{code} = 1;
                    $refhErrorOutput->{msg} = "SNMP problem: ".$refoSession->error();
                    $refoSession->close();
                    return ($refhResultOutput, $refhErrorOutput);
                }
            }

            # check result validity
            if ($stdSNMPOutBehavior == 1) {
                $refhSnmpResult->{"$OID"} = StandardizeSNMPOutputBehaviour($refhSnmpResult->{"$OID"});
            }
            
            # fill hash with data
            $refhResultOutput->{$OID} = $refhSnmpResult->{$OID};
        }
    } else { 
        # session establishment problem
        logger(0, "SNMP session object creation problem: ".$sessionError);
        $refhErrorOutput->{code} = 1;
        $refhErrorOutput->{msg} = "SNMP session object creation problem: ".$sessionError;
    }

    # return the complete hash with OIDs as keys or
    # undef if the SNMP session fails
    return ($refhResultOutput, $refhErrorOutput);
}

# ------------------------------------------------------------------------

sub GetDataWithSnmp {

    ################################
    # SUB use: Get Data with perl net-snmp module
    # SUB specs:
    #  * arg 0: host
    #  * arg 1: hash of SNMP options
    #  * arg 2: OID
    #  * arg 3: Directory for cached data
    #  * arg 4: Cache timer
    #  * return: value retrieved by snmp
    ################################

    my $host            = shift;
    my $refhSNMPOptions = shift;
    my $refaOID         = shift;    # ref to array of OIDs
    my $CacheDir        = shift;
    my $CacheTimer      = shift;
    
    unless ($CacheTimer) {$CacheTimer = 0;}
    my $stdSNMPOutBehavior  = 1;
    my $refhResult;
    my $refhError;
    $refhError->{code} = 0;
    $refhError->{msg} = "";
    
    if ( not $refhSNMPOptions->{'unixsnmp'} ) {
        # gather data via perl's snmp
        my %refhSnmpQueryOptions = (
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -version    => "$refhSNMPOptions->{'version'}",
            -domain     => "$refhSNMPOptions->{'domain'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            -retries    => "$refhSNMPOptions->{'retries'}",
            -translate  => [ -timeticks => 0x0 ], # disable conversion get raw timeticks
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching
        );
        if ( $refhSNMPOptions->{'version'} eq 3 ) {
            $refhSnmpQueryOptions{'-username'}     = "$refhSNMPOptions->{'login'}";
            $refhSnmpQueryOptions{'-authpassword'} = "$refhSNMPOptions->{'passwd'}";
            $refhSnmpQueryOptions{'-authprotocol'} = "$refhSNMPOptions->{'authproto'}";
            if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
                $refhSnmpQueryOptions{'-privpassword'} = "$refhSNMPOptions->{'privpass'}";
                $refhSnmpQueryOptions{'-privprotocol'} = "$refhSNMPOptions->{'privproto'}";
            }
            defined $refhSNMPOptions->{'contextname'} and $refhSnmpQueryOptions{'-contextname'} = "$refhSNMPOptions->{'contextname'}";
        } else {
            $refhSnmpQueryOptions{'-community'} = "$refhSNMPOptions->{'community'}";
        }
        ($refhResult, $refhError) = SnmpGet (\%refhSnmpQueryOptions);
    } else {
        # gather data via unix snmpget
        my $snmpQueryCommand = "snmpbulkget";
        my $snmpQueryOptions = "-Oqne -t $refhSNMPOptions->{'timeout'} -r $refhSNMPOptions->{'retries'} ";
        $snmpQueryOptions .= ($refhSNMPOptions->{'version'} == 2) ? "-v 2c " : "-v $refhSNMPOptions->{'version'} ";
        if ( $refhSNMPOptions->{'version'} eq 3 ) {
            if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
                $snmpQueryOptions .= "-u $refhSNMPOptions->{'login'} -l authPriv -a $refhSNMPOptions->{'authproto'} -A $refhSNMPOptions->{'passwd'} -X $refhSNMPOptions->{'privpass'} -x $refhSNMPOptions->{'privproto'} ";
            } else {
                $snmpQueryOptions .= "-u $refhSNMPOptions->{'login'} -l authNoPriv -a $refhSNMPOptions->{'authproto'} -A $refhSNMPOptions->{'passwd'} "
            }
            defined $refhSNMPOptions->{'max-repetitions'} and $snmpQueryOptions .= "-Cr$refhSNMPOptions->{'max-repetitions'} ";
            defined $refhSNMPOptions->{'contextname'} and $snmpQueryOptions .= "-n$refhSNMPOptions->{'contextname'} ";
        } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
            $snmpQueryOptions .= "-c $refhSNMPOptions->{'community'} ";
            defined $refhSNMPOptions->{'max-repetitions'} and $snmpQueryOptions .= "-Cr$refhSNMPOptions->{'max-repetitions'} ";
        } else {
            $snmpQueryCommand = "snmpget";
            $snmpQueryOptions .= "-c $refhSNMPOptions->{'community'} ";
        }
        my $snmpQueryOID = join(' ',@$refaOID);
        my ($refaCommandResult, $commandExitCode) = ExecuteCommand ({
                Command     => "$snmpQueryCommand $snmpQueryOptions $refhSNMPOptions->{'domain'}:${host}:$refhSNMPOptions->{'port'} $snmpQueryOID",
                Retry       => 2,
                CacheDir    => $CacheDir,
                CacheTimer  => int rand ($CacheTimer),
            });
        $refhError->{code} = $commandExitCode;
        $refhError->{msg} = "";
        
        foreach my $line (@$refaCommandResult) {
            if ($stdSNMPOutBehavior == 1) {
                $line = StandardizeSNMPOutputBehaviour($line);
            }
            if ($line ne "") {
                my ($OID,$Value) = split / /,$_,2;
                $OID   =~ s/\s+$//g;     # remove invisible chars from the end
                $Value =~ s/\s+$//g;     # remove invisible chars from the end
                $refhResult->{"$OID"} = "$Value";
            }
        }
    }
    
    return ($refhResult, $refhError);
}


#============================================================================#
# Table OID request via perl's netsnmp or unix snmpwalk/snmpbulkwalk
#----------------------------------------------------------------------------#
# SnmpGetTable
#
#----------------------------------------------------------------------------#

sub SnmpGetTable {

    ################################
    # SUB use:
    # SUB specs:
    #  * arg 0:
    #  * return:
    ################################

    my $refhStruct = shift;

    # store variables and delete them from the hash
    # this is necessary for the snmp session which takes the same
    # hash ref and does not work with arguments other than starting
    # with a dash
    my $refaOIDs            = $refhStruct->{OID}; # ref to array of OIDs
    my $GlobalCacheDir      = $refhStruct->{CacheDir};
    my $GlobalCacheTimer    = $refhStruct->{CacheTimer};
    
    my $stdSNMPOutBehavior     = 1;

    delete $refhStruct->{OID};
    delete $refhStruct->{CacheDir};
    delete $refhStruct->{CacheTimer};

    my $refoSession;    # SNMP session object
    my $sessionError;   # SNMP session error

    my $refhQuery = ();
    if (defined $refhStruct->{'-maxrepetitions'}) {
        $refhQuery->{'-maxrepetitions'} = $refhStruct->{'-maxrepetitions'};
        delete $refhStruct->{'-maxrepetitions'};
    }
    if (defined $refhStruct->{'-contextname'}) {
        $refhQuery->{'-contextname'} = $refhStruct->{'-contextname'};
        delete $refhStruct->{'-contextname'};
    }

    my $refhErrorOutput;
    $refhErrorOutput->{code} = 0;
    $refhErrorOutput->{msg} = "";
    my $refhResultOutput;

    # example cache dir name
    my $CacheDir = "$GlobalCacheDir/SnmpGetTable";

    # Create the directory if not exist
    not -d $CacheDir and MyMkdir($CacheDir);

    # create snmp session
    ($refoSession,$sessionError) = Net::SNMP->session (%$refhStruct);

    if (defined $refoSession) {

        my $OIDLine;    # one line of OIDs or OIDs and caching timers
                
        # OIDs come in an array (ref) - go through each
        # example:
        #    $refaOIDs = [
        #              '.1.3.6.1.2.1.2.2.1.11.1',
        #              '.1.3.6.1.2.1.2.2.1.12.1'
        #            ];
        for $OIDLine (@$refaOIDs) {
        
            my $refhSnmpResult=undef;
            my  $CacheTimer=0;
    
            # OID could be .1.3.6.1.2.1.2.2.1.11.1,200
            # <OID>,<CacheTimer> for this OID only
            my ($OID,$OIDCacheTimer) = ("","");
            ($OID,$OIDCacheTimer) = split ',',$OIDLine,2;
            $refhQuery->{'-baseoid'} = "$OID";
    
            if (defined $OIDCacheTimer) {
                # remove non digits
                $OIDCacheTimer =~ s/\D//g;
                if ("X$OIDCacheTimer" eq "X") { # is empty?
                    $CacheTimer = $GlobalCacheTimer;
                } else {
                    $CacheTimer = $OIDCacheTimer;
                }
            } else {
                $CacheTimer = $GlobalCacheTimer;
            }
    
            my $readFromCache = 0;
            if ($CacheTimer > 0) {
                if (-r "${CacheDir}/${OID}.dat") {
                    logger(3, "Cached data file found: ${CacheDir}/${OID}.dat, cacheTimer=${CacheTimer}s");
                    my @FileProperties=stat("${CacheDir}/${OID}.dat");
    
                    # $FileProperties[9] = LastModifyTime of file
                    # only read the cache file if it is not too old
                    if (time - $CacheTimer < $FileProperties[9]) {
                        logger(3, " valid cached data, loading");
                        $refhSnmpResult = retrieve("${CacheDir}/${OID}.dat");
                        die "Unable to retrieve from ${CacheDir}/${OID}.dat: $!\n" unless defined $refhSnmpResult;
                        # leave this subroutine with cached data found
                        $readFromCache = 1;
                    } else {
                        logger(3, " expired cached data, skipping");
                    }
                }
            }
            
            unless (defined $refhSnmpResult) {$refhSnmpResult = {};}
            # snmp value not from cache - read it from the net
            if ($readFromCache == 0) {
                $refhSnmpResult = $refoSession->get_table(%$refhQuery);
                if (defined $refhSnmpResult) {
                    logger(3, "Data collected from net: base-OID=${OID}, cacheTimer=${CacheTimer}s");

                    foreach my $i (keys %$refhSnmpResult) {
                        logger(3, "  oid: $i, value: $refhSnmpResult->{\"$i\"}");
                        
                        # remove non ascii chars incl. \r and \n
                        $refhSnmpResult->{"$i"} =~  s/[\000-\037]|[\177-\377]//g;
                        # replace ; with , - just to be sure
                        $refhSnmpResult->{"$i"} =~  s/;/,/g;
        
                        # check result validity
                        if ($stdSNMPOutBehavior == 1) {
                            $refhSnmpResult->{"$i"} = StandardizeSNMPOutputBehaviour($refhSnmpResult->{"$i"});
                        }
                    }                    
                
                    
                    # write a cache file if the cache timer > 0
                    if ($CacheTimer > 0) {
                        logger(3, "Write cache file ${CacheDir}/${OID}.dat, CacheTimer=$CacheTimer");
                        umask "0000"; # change to rw-rw-rw maybe changed later because of security
                        store ($refhSnmpResult, "${CacheDir}/${OID}.dat") or die "cannot store to ${CacheDir}/${OID}.dat: $!";
                    }
                } else {
                    logger(0, "SNMP problem: ".$refoSession->error());
                    $refhErrorOutput->{code} = 1;
                    $refhErrorOutput->{msg} = "SNMP problem: ".$refoSession->error();
                    $refoSession->close();
                    return ($refhResultOutput, $refhErrorOutput);
                }
            }
            
            # fill hash with data
            @$refhResultOutput{keys %$refhSnmpResult} = values %$refhSnmpResult;
        }
    } else {
        # session establishment problem
        logger(0, "SNMP session object creation problem: ".$sessionError);
        $refhErrorOutput->{code} = 1;
        $refhErrorOutput->{msg} = "SNMP session object creation problem: ".$sessionError;
    }
      
    return ($refhResultOutput, $refhErrorOutput);
}

#----------------------------------------------------------------------------#

sub GetTableDataWithSnmp {

    ################################
    # SUB use: Get multiple Data with perl net-snmp module
    #          or unix snmpwalk/snmpbulkwalk
    # SUB specs:
    #  * arg 0: host
    #  * arg 1: hash of SNMP options
    #  * arg 2: hash of info on the target OID
    #  * arg 3: Directory for cached data
    #  * arg 4: Cache timer
    #  * arg 5: notEmpty flag (error when empty result array)
    #  * return: hash of values retrieved by snmp
    ################################

    my $host            = shift;
    my $refhSNMPOptions = shift;
    my $refaOID         = shift;    # ref to array of OIDs
    my $CacheDir        = shift;
    my $CacheTimer      = shift;
    my $notEmpty        = shift;
    
    unless ($CacheTimer) {$CacheTimer = 0;}
    my $stdSNMPOutBehavior = 1;
    my $refhResult;
    my $refhError;
    $refhError->{code} = 0;
    $refhError->{msg} = "";
    my $refaLinesTmp    = ();
    my $refaLines       = ();
    my $refhOID; #TEMPORARY
    
    if ( not $refhSNMPOptions->{'unixsnmp'} ) {
        # gather data via perl's snmp
        my %refhSnmpQueryOptions = (
            -hostname   => "$host",
            -port       => "$refhSNMPOptions->{'port'}",
            -version    => "$refhSNMPOptions->{'version'}",
            -domain     => "$refhSNMPOptions->{'domain'}",
            -timeout    => "$refhSNMPOptions->{'timeout'}",
            -retries    => "$refhSNMPOptions->{'retries'}",
            OID         => $refaOID,
            CacheDir    => "$CacheDir",
            CacheTimer  => int rand ($CacheTimer),  # random caching;
        );
        if ( $refhSNMPOptions->{'version'} eq 3 ) {
            $refhSnmpQueryOptions{'-username'}     = "$refhSNMPOptions->{'login'}";
            $refhSnmpQueryOptions{'-authpassword'} = "$refhSNMPOptions->{'passwd'}";
            $refhSnmpQueryOptions{'-authprotocol'} = "$refhSNMPOptions->{'authproto'}";
            if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
                $refhSnmpQueryOptions{'-privpassword'} = "$refhSNMPOptions->{'privpass'}";
                $refhSnmpQueryOptions{'-privprotocol'} = "$refhSNMPOptions->{'privproto'}";
            }
            defined $refhSNMPOptions->{'max-repetitions'} and $refhSnmpQueryOptions{'-maxrepetitions'} = "$refhSNMPOptions->{'max-repetitions'}";
            defined $refhSNMPOptions->{'contextname'} and $refhSnmpQueryOptions{'-contextname'} = "$refhSNMPOptions->{'contextname'}";
        } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
            $refhSnmpQueryOptions{'-community'} = "$refhSNMPOptions->{'community'}";
            defined $refhSNMPOptions->{'max-repetitions'} and $refhSnmpQueryOptions{'-maxrepetitions'} = "$refhSNMPOptions->{'max-repetitions'}";
        } else {
            $refhSnmpQueryOptions{'-community'} = "$refhSNMPOptions->{'community'}";
        }
        ($refhResult, $refhError) = SnmpGetTable (\%refhSnmpQueryOptions);
    } else {
        # gather data via unix snmpwalk/snmpbulkwalk
        my $snmpQueryCommand = "snmpbulkwalk";
        my $snmpQueryOptions = "-Oqne -t $refhSNMPOptions->{'timeout'} -r $refhSNMPOptions->{'retries'} ";
        $snmpQueryOptions .= ($refhSNMPOptions->{'version'} == 2) ? "-v 2c " : "-v $refhSNMPOptions->{'version'} ";
        if ( $refhSNMPOptions->{'version'} eq 3 ) {
            if (defined $refhSNMPOptions->{'privpass'} and $refhSNMPOptions->{'privpass'} ne "") {
                $snmpQueryOptions .= "-u $refhSNMPOptions->{'login'} -l authPriv -a $refhSNMPOptions->{'authproto'} -A $refhSNMPOptions->{'passwd'} -X $refhSNMPOptions->{'privpass'} -x $refhSNMPOptions->{'privproto'} ";
            } else {
                $snmpQueryOptions .= "-u $refhSNMPOptions->{'login'} -l authNoPriv -a $refhSNMPOptions->{'authproto'} -A $refhSNMPOptions->{'passwd'} "
            }
            defined $refhSNMPOptions->{'max-repetitions'} and $snmpQueryOptions .= "-Cr$refhSNMPOptions->{'max-repetitions'} ";
            defined $refhSNMPOptions->{'contextname'} and $snmpQueryOptions .= "-n$refhSNMPOptions->{'contextname'} ";
        } elsif ( $refhSNMPOptions->{'version'} eq 2 ) {
            $snmpQueryOptions .= "-c $refhSNMPOptions->{'community'} ";
            defined $refhSNMPOptions->{'max-repetitions'} and $snmpQueryOptions .= "-Cr$refhSNMPOptions->{'max-repetitions'} ";
        } else {
            $snmpQueryCommand = "snmpwalk";
            $snmpQueryOptions .= "-c $refhSNMPOptions->{'community'} ";
        }
        ($refaLinesTmp) = ExecuteCommand ({
            Command     => "$snmpQueryCommand $snmpQueryOptions $refhSNMPOptions->{'domain'}:${host}:$refhSNMPOptions->{'port'} $refhOID->{'oid'}",
            Retry       => 2,
            CacheDir    => $CacheDir,
            CacheTimer  => int rand ($CacheTimer),
        });

        # check result validity
        foreach my $line ( @$refaLinesTmp ) {
            if ($stdSNMPOutBehavior == 1) {
                $line = StandardizeSNMPOutputBehaviour($line);
            }
            if ($line ne "") {
                push(@$refaLines, $line);
            }
        }
    }
    
    #  if ( $notEmpty and $#$refaLines < 0 ) {
    #      if ($refhOID->{'mib'}) {
    #          logger(0, "Could not read $refhOID->{'name'} information from host \"$host\" with snmp\nCheck the access to the oid $refhOID->{'oid'} ($refhOID->{'mib'})\n");
    #      } else {
    #          logger(0, "Could not read $refhOID->{'name'} information from host \"$host\" with snmp\nCheck the access to the oid $refhOID->{'oid'}\n");
    #      }
    #      exit 3;
    #  }

    return ($refhResult, $refhError);
}


#============================================================================#
# Other functions
#----------------------------------------------------------------------------#
# ExecuteCommand
# StandardizeSNMPOutputBehaviour
#----------------------------------------------------------------------------#

# ------------------------------------------------------------------------
# ExecuteCommand Routine. Enhanced with our cache algorith...

sub ExecuteCommand {
    my $refhStruct      = shift;
    my $Command         = $refhStruct->{Command};
    my $GlobalCacheDir  = $refhStruct->{CacheDir};

    my $refaLines=[];   # Pointer to Array of strings (output)

    my $CacheFile;      # Filename storing cached data
    my $ExitCode;       # exit code of the unix command

    my $Now=time();     # current time in seconds since epoch

    my $CacheDir="$GlobalCacheDir/ExecuteCommand/"; # cache dir

    # Create Cachedir if not exist
    not -d $CacheDir and MyMkdir($CacheDir);

    # If caching for this command is enabled
    if ($refhStruct->{CacheTimer} > 0) {
        $CacheFile = $CacheDir . normalize ("$Command");
        if (-r "$CacheFile") {
            logger(3, "Cached data file found: $CacheFile, cacheTimer=$refhStruct->{CacheTimer}s");
            my @FileProperties=stat($CacheFile);

            # $FileProperties[9] = LastModifyTime of file
            # only read the cache file if it is not too old
            if ($Now-$refhStruct->{CacheTimer} < $FileProperties[9]) {
                logger(3, " valid cached data, loading");
                # open (IN,"<$CacheFile");
                #     @$refaLines=<IN>;
                # close (IN);
                $refaLines = retrieve($CacheFile);
                foreach (@$refaLines) {
                    $_ =~ s/\n$//g;
                    logger(3, "   data: $_");
                }
                # leave this subroutine with cached data found
                return ($refaLines,0);
            } else {
                logger(3, " expired cached data, skipping");
            }
        }
    }

    # execute the unix command
    open(UNIX,"$Command |") or die "[ERROR] Failed to execute \"$Command\", $!";
        while (<UNIX>) {
            $_ =~ s/^\.*([0-9.]*) "?(.*)/\1 \2/g;
            $_ =~ s/"$//g;
            push @$refaLines,$_;
        }
    close(UNIX);
    $ExitCode=$? >> 8; # calculate the exit code
    logger(3, "Executed \"$Command\" and got ExitCode \"$ExitCode\"");

    # stop in case of error
    if ($ExitCode != 0) {
        logger(0, "The UNIX command \"$Command\" returned the ExitCode \"$ExitCode\"");
        exit 1;
    }

    # write a cache file if the cache timer > 0
    if ($refhStruct->{CacheTimer} > 0) {
        logger(3, "Write cache file $CacheFile, CacheTimer=$refhStruct->{CacheTimer}");
        umask "0000"; # change to rw-rw-rw maybe changed later because of security
        # open (OUT,">$CacheFile") or return ($refaLines,$ExitCode);
        #     print OUT @$refaLines;
        # close (OUT);
        store ($refaLines, "$CacheFile") or die "cannot store to $CacheFile: $!";
    }
    return ($refaLines,$ExitCode);
}

sub StandardizeSNMPOutputBehaviour {
    my $snmpResult = shift;
    if ($snmpResult =~ /noSuchObject/) {
        # Replacing noSuchObject by an empty string.
        # Indeed, the different snmp versions handle requests for missing oids
        # differently. v1 always returns an empty string. v2c/v3 return "noSuchObject"
        # string, and -translate noSuchObject -> '' correct that. BUt we do the change
        # to empty string after to be able to inform the user. Also, snmpwalk and other
        # unix programs don't have such a translate option.
        # Ex: snmpwalk
        # [icinga@server libexec]$ snmpwalk -Oqn -v 1 -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
        # [icinga@server libexec]$
        # [icinga@server libexec]$ snmpwalk -Oqn -v 2c -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
        # .1.3.6.1.4.1.9.5.1.2.16.0 No Such Object available on this agent at this OID
        # [icinga@server libexec]$
        $snmpResult = "";
        logger(3, "Data validity check: no such objet in the mib. SNMP behavior standardization enabled, replacing by ''");
    }
    elsif ($snmpResult =~ /noSuchInstance/) {
        # Replacing noSuchInstance by an empty string.
        # Indeed, the different snmp versions handle requests for missing oids
        # differently. v1 always returns an empty string. v2c/v3 return "noSuchInstance"
        $snmpResult = "";
        logger(3, "Data validity check: no such objet in the mib. SNMP behavior standardization enabled, replacing by ''");
    }
    elsif ($snmpResult =~ /No Such Object available on this agent at this OID/) {
        # Replacing "No Such Object available on this agent at this OID" by an empty string.
        # Indeed, the different snmp versions handle requests for missing oids
        # differently. While v1 returns an empty string, v2c/v3 return "noSuchObject"
        # string
        # Ex: snmpwalk
        # [icinga@server libexec]$ snmpwalk -Oqn -v 1 -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
        # [icinga@server libexec]$
        # [icinga@server libexec]$ snmpwalk -Oqn -v 2c -t 15 -c community xxxxxxxxxxx:161 .1.3.6.1.4.1.9.5.1.2.16.0
        # .1.3.6.1.4.1.9.5.1.2.16.0 No Such Object available on this agent at this OID
        # [icinga@server libexec]$
        #
        #30/08/2012: commenting return to force empty check 
        #logger(2, "Data validity check: $line, no such objet in the mib. Strict mode disabled, returning an empty array");
        #return $refaLines;
        $snmpResult = "";
        logger(3, "Data validity check: no such objet in the mib. SNMP behavior standardization enabled, replacing by ''");
    }
    return $snmpResult;
}


1;

__END__

# vi: set ts=4 sw=4 expandtab :
